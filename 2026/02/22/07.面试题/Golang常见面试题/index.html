<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
    <meta name="referrer" content="origin">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <title>
        
            Golang常见面试题
        
    </title>
    <link rel="shortcut icon" href="#"/>

    <link type="text/css" rel="stylesheet" href="/font/LongCang.css">
    <link type="text/css" rel="stylesheet" href="/font/Monda.css">
    <link type="text/css" rel="stylesheet" href="/font/NotoSansSC.css">
    <link type="text/css" rel="stylesheet" href="/font/NotoSerifSC.css">
    <link type="text/css" rel="stylesheet" href="/font/Playball.css">
    <link type="text/css" rel="stylesheet" href="/font/PTMono.css">
    <link type="text/css" rel="stylesheet" href="/font/Roboto.css">
    <link type="text/css" rel="stylesheet" href="/font/RobotoSlab.css">
    <link type="text/css" rel="stylesheet" href="/font/Rosario.css">
    <link type="text/css" rel="stylesheet" href="/font/UbuntuMono.css">

    <link type="text/css" rel="stylesheet" href="/css/base.css">
    <link type="text/css" rel="stylesheet" href="/css/code.css">
    <link type="text/css" rel="stylesheet" href="/css/prism-one-dark-pro.css">

    <script type="text/javascript" src="/js/jquery-3.4.1.min.js"></script>
<meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/css/prism-one-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
<body>
    <a id="cover"></a>
    <link type="text/css" rel="stylesheet" href="/css/post.css">
<div id="header" class="header">
    <div class="vertical">
        <div class="inner">
            
                <h1 class="header-subtitle">Golang常见面试题</h1>
                <div class="header-subinfo">
                    <p class="article-info-text">
                        <span>
                            <i class="iconfont icon-time"></i> 发表时间：2026-02-22
                        </span>
                        
                            
                                <span id="/2026/02/22/07.面试题/Golang常见面试题/" class="leancloud_visitors" data-flag-title="Golang常见面试题">
                                    <i class="iconfont icon-browse"></i> 阅读：<sapn class="leancloud-visitors-count"></span>
                                </span>
                            
                            
                                <span>
                                    <i class="iconfont icon-interactive"></i> 评论：<span class="valine-comment-count" data-xid="/2026/02/22/07.面试题/Golang常见面试题/"></span>
                                </span>
                              
                        
                    </p>
                    
                        
                            <span class="category-color">go</span>
                        
                            <span class="category-color">面试题</span>
                        
                    
                    
                        
                            <span class="tag-color">go</span>
                        
                            <span class="tag-color">面试题</span>
                        
                    
                </div>
            
        </div>
    </div>
    
</div>
<div id="container">
    
        <!-- 文章页面 -->
        <div id="article">
            <div class="toc"></div>
            <div class="article-body">
                <p><a target="_blank" rel="noopener" href="https://python-web-guide.readthedocs.io/zh/latest/go-note/web.html#id1">https://python-web-guide.readthedocs.io/zh/latest/go-note/web.html#id1</a></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://markdown.lovejade.cn/">https://markdown.lovejade.cn/</a></li>
<li><a target="_blank" rel="noopener" href="https://learnku.com/articles/62720">https://learnku.com/articles/62720</a></li>
</ul>
<h1 id="golang常见面试题"><a class="markdownIt-Anchor" href="#golang常见面试题"></a> Golang常见面试题</h1>
<h2 id="1golang中make和new的区别"><a class="markdownIt-Anchor" href="#1golang中make和new的区别"></a> 1.golang中make和new的区别？</h2>
<ul>
<li>make用于创建切片、映射和通道，并返回初始化后的（非零）值。</li>
<li>new用于分配内存，返回指向类型零值的指针。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th>new</th>
<th>make</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>返回值</strong></td>
<td>返回指针 *T</td>
<td>返回类型本身 T</td>
</tr>
<tr>
<td><strong>适用类型</strong></td>
<td>所有类型</td>
<td>仅slice、map、channel</td>
</tr>
<tr>
<td><strong>初始化</strong></td>
<td>零值初始化</td>
<td>分配并初始化内部数据</td>
</tr>
<tr>
<td><strong>是否可用</strong></td>
<td>返回的指针指向零值</td>
<td>返回可直接使用的对象</td>
</tr>
</tbody>
</table>
<h3 id="11-newt"><a class="markdownIt-Anchor" href="#11-newt"></a> 1.1  new(T)</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 分配0值内存，返回指向类型T的指针 *T</span></span><br><span class="line">p := <span class="built_in">new</span>(<span class="type">int</span>) <span class="comment">// p是一个*int类型的指针，指向一个int类型的零值</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// 输出0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">p := &amp;i</span><br></pre></td></tr></table></figure>
<h3 id="12-maket-args"><a class="markdownIt-Anchor" href="#12-maket-args"></a> 1.2 make(T, args)</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>) <span class="comment">// 创建一个长度为5的int切片</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">// 创建一个空的map</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>) <span class="comment">// 创建一个缓冲区大小为10的int通道</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="13-代码对比"><a class="markdownIt-Anchor" href="#13-代码对比"></a> 1.3 代码对比</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// new 示例</span></span><br><span class="line">    p1 := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;new(int): %T, 值: %v, 地址: %p\n&quot;</span>, p1, *p1, p1)</span><br><span class="line">    <span class="comment">// 输出: new(int): *int, 值: 0, 地址: 0xc000014098</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. new 用于 slice（不推荐）</span></span><br><span class="line">    p2 := <span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;new([]int): %T, 值: %v, 是否nil: %v\n&quot;</span>, p2, *p2, *p2 == <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 输出: new([]int): *[]int, 值: [], 是否nil: true</span></span><br><span class="line">    <span class="comment">// *p2 是 nil，不能直接使用！</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============ make 示例 ============</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. make 用于 slice</span></span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;make([]int): %T, len: %d, cap: %d\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">    <span class="comment">// 输出: make([]int): []int, len: 5, cap: 10</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">100</span> <span class="comment">// 可以直接使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. make 用于 map</span></span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    m[<span class="string">&quot;key&quot;</span>] = <span class="number">42</span> <span class="comment">// 可以直接使用</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;make(map): %T, 值: %v\n&quot;</span>, m, m)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. make 用于 channel</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span> <span class="comment">// 可以直接使用</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;make(chan): %T\n&quot;</span>, ch)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<ul>
<li>new: 通用分配器，返回指针，零值初始化</li>
<li>make: 专用于 slice/map/channel，返回已初始化的可用对象</li>
</ul>
<h1 id="2-数组和切片的区别"><a class="markdownIt-Anchor" href="#2-数组和切片的区别"></a> 2、数组和切片的区别？</h1>
<table>
<thead>
<tr>
<th>特性</th>
<th>数组（Array）</th>
<th>切片（Slice）</th>
</tr>
</thead>
<tbody>
<tr>
<td>长度</td>
<td>固定，编译时确定</td>
<td>动态、可变</td>
</tr>
<tr>
<td>类型</td>
<td>值类型</td>
<td>引用类型</td>
</tr>
<tr>
<td>内存</td>
<td>直接存储元素</td>
<td>包含指针、长度、容量</td>
</tr>
<tr>
<td>传递</td>
<td>拷贝整个数组</td>
<td>拷贝切片头(24字节)</td>
</tr>
</tbody>
</table>
<h2 id="21-声明和初始化"><a class="markdownIt-Anchor" href="#21-声明和初始化"></a> 2.1 声明和初始化</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组： 长度是类型的一部分</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span>  <span class="comment">// [0 0 0 0 0]</span></span><br><span class="line">arr2 :=[<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">// [1 2 3]</span></span><br><span class="line">arr3 := [...]<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; <span class="comment">// 自动计算长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片： 长度可变</span></span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="type">int</span>    <span class="comment">// nil 切片</span></span><br><span class="line">slice2 := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">// [1 2 3]</span></span><br><span class="line">slice3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>) <span class="comment">// [0 0 0 0 0]</span></span><br><span class="line">slice4 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">10</span>) <span class="comment">// 长度3，容量10</span></span><br></pre></td></tr></table></figure>
<h2 id="22-类型特性"><a class="markdownIt-Anchor" href="#22-类型特性"></a> 2.2 类型特性</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数组是值类型，赋值会拷贝整个数组</span></span><br><span class="line">arr := [<span class="number">3</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">arr2 := arr    <span class="comment">// 完整拷贝</span></span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(arr)  <span class="comment">// [1 2 3]  不受影响</span></span><br><span class="line">fmt.Println(arr2) <span class="comment">// [100 2 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片是引用类型，赋值会拷贝切片头</span></span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">slice2 := slice  <span class="comment">// 只拷贝切片头,底层数据共享</span></span><br><span class="line">slice2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(slice)  <span class="comment">// [100 2 3] 受影响</span></span><br><span class="line">fmt.Println(slice2) <span class="comment">// [100 2 3]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="23-长度和容量"><a class="markdownIt-Anchor" href="#23-长度和容量"></a> 2.3 长度和容量</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数组: 长度固定</span></span><br><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(arr)) <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// arr = append(arr, 6) // 编译错误，不能改变长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片： 长度可变，有容量概念</span></span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))   <span class="comment">//2 - 长度</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))   <span class="comment">//3 - 容量</span></span><br><span class="line"></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">4</span>) <span class="comment">// 可以追加元素</span></span><br><span class="line">fmt.Println(slice) <span class="comment">// [1 2 3 4]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="24-函数传递"><a class="markdownIt-Anchor" href="#24-函数传递"></a> 2.4 函数传递</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数组传递：值拷贝，影响性能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray</span><span class="params">(arr [10000] <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">100</span>   <span class="comment">// 不会影响原数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片传递：只拷贝切片头(24字节)，高效</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(slice []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    slice[<span class="number">0</span>] = <span class="number">100</span>  <span class="comment">// 会影响原切片的底层数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="25-切片的底层结构"><a class="markdownIt-Anchor" href="#25-切片的底层结构"></a> 2.5 切片的底层结构</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切片的内部结构</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer   <span class="comment">// 指向底层数组的指针</span></span><br><span class="line">    <span class="built_in">len</span> <span class="type">int</span>   <span class="comment">// 长度</span></span><br><span class="line">    <span class="built_in">len</span> <span class="type">int</span>   <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="26-使用场景"><a class="markdownIt-Anchor" href="#26-使用场景"></a> 2.6 使用场景</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数组：长度固定， 明确已知</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessFixedData</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer [<span class="number">1024</span>]<span class="type">byte</span>   <span class="comment">//固定大小的缓冲区</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片： 长度不确定，需要动态操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processDynamicData</span><span class="params">()</span></span>&#123;</span><br><span class="line">    data := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    data = <span class="built_in">append</span>(data, <span class="string">&quot;item1&quot;</span>)</span><br><span class="line">    data = <span class="built_in">append</span>(data, <span class="string">&quot;item2&quot;</span>)</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="27-数组转切片"><a class="markdownIt-Anchor" href="#27-数组转切片"></a> 2.7 数组转切片</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">slice1 := arr[:]   <span class="comment">//完整切片</span></span><br><span class="line">slice2 := arr[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">// [2 3 4]</span></span><br><span class="line">slice3 := arr[:<span class="number">3</span>]     <span class="comment">// [1 2 3]</span></span><br><span class="line">slice4 := arr[<span class="number">2</span>:]     <span class="comment">// [3 4 5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="28-最佳实践建议"><a class="markdownIt-Anchor" href="#28-最佳实践建议"></a> 2.8 最佳实践建议</h2>
<ol>
<li>优先使用切片： 大多数情况下使用切片更灵活</li>
<li>明确长度时使用数组： 如固定大小的缓冲区，md5哈希值等</li>
<li>注意切片陷阱： 切片恭喜底层数组，丢修改要小心</li>
<li>预分配容量：使用 make([]T, len, cap) 可以减少扩容次数</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的做法：预分配容量</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    slice = <span class="built_in">append</span>(slice, i)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="3-for-range-的时候它的地址会发生变化么"><a class="markdownIt-Anchor" href="#3-for-range-的时候它的地址会发生变化么"></a> 3、for range 的时候它的地址会发生变化么？</h1>
<p>迭代变量的地址不会变化！ 这是go非常重要的特性</p>
<h2 id="31-基本现象"><a class="markdownIt-Anchor" href="#31-基本现象"></a> 3.1 基本现象</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">     fmt.Printf(<span class="string">&quot;i的地址: %p, v的地址: %p, v的值: %d\n&quot;</span>, &amp;i, &amp;v, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// i的地址: 0xc000018090, v的地址: 0xc000018098, v的值: 1</span></span><br><span class="line"><span class="comment">// i的地址: 0xc000018090, v的地址: 0xc000018098, v的值: 2</span></span><br><span class="line"><span class="comment">// i的地址: 0xc000018090, v的地址: 0xc000018098, v的值: 3</span></span><br><span class="line"><span class="comment">// i的地址: 0xc000018090, v的地址: 0xc000018098, v的值: 4</span></span><br><span class="line"><span class="comment">// i的地址: 0xc000018090, v的地址: 0xc000018098, v的值: 5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="32-常见陷阱-指针切片"><a class="markdownIt-Anchor" href="#32-常见陷阱-指针切片"></a> 3.2 常见陷阱-指针切片</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> result []*<span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, &amp;v)  <span class="comment">// 错误！所有指针都指向同一个地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> result &#123;</span><br><span class="line">        fmt.Print(*p, <span class="string">&quot; &quot;</span>)  <span class="comment">// 输出: 5 5 5 5 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确做法1：创建临时变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> result []*<span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        temp := v  <span class="comment">// 创建新变量</span></span><br><span class="line">        result = <span class="built_in">append</span>(result, &amp;temp)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> result &#123;</span><br><span class="line">        fmt.Print(*p, <span class="string">&quot; &quot;</span>)  <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确做法2：使用索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> result []*<span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, &amp;slice[i])  <span class="comment">// 直接取原切片元素的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> result &#123;</span><br><span class="line">        fmt.Print(*p, <span class="string">&quot; &quot;</span>)  <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="33-闭包陷阱"><a class="markdownIt-Anchor" href="#33-闭包陷阱"></a> 3.3 闭包陷阱</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> funcs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        funcs = <span class="built_in">append</span>(funcs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Print(v, <span class="string">&quot; &quot;</span>)  <span class="comment">// 闭包捕获的是变量v的地址</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">        f()  <span class="comment">// 输出: 5 5 5 5 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确做法1：传参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> funcs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        v := v  <span class="comment">// 创建新变量（Go 1.22之前需要）</span></span><br><span class="line">        funcs = <span class="built_in">append</span>(funcs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Print(v, <span class="string">&quot; &quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">        f()  <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确做法2：函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> funcs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        funcs = <span class="built_in">append</span>(funcs, <span class="function"><span class="keyword">func</span><span class="params">(val <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                fmt.Print(val, <span class="string">&quot; &quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(v))  <span class="comment">// 立即执行，传入v的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">        f()  <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="34-goroutine-陷阱"><a class="markdownIt-Anchor" href="#34-goroutine-陷阱"></a> 3.4. goroutine 陷阱</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Print(v, <span class="string">&quot; &quot;</span>)  <span class="comment">// 可能输出: 5 5 5 5 5（不确定）</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确做法：传参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(val <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Print(val, <span class="string">&quot; &quot;</span>)  <span class="comment">// 输出顺序不定，但值正确</span></span><br><span class="line">        &#125;(v)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="35-结构体切片的陷阱"><a class="markdownIt-Anchor" href="#35-结构体切片的陷阱"></a> 3.5. 结构体切片的陷阱</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    persons := []Person&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> result []*Person</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> persons &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, &amp;p)  <span class="comment">// 错误！</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> result &#123;</span><br><span class="line">        fmt.Println(p)  <span class="comment">// 全部输出: &amp;&#123;Charlie 35&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确做法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    persons := []Person&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> result []*Person</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> persons &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, &amp;persons[i])  <span class="comment">// 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> result &#123;</span><br><span class="line">        fmt.Println(p)  <span class="comment">// 正确输出每个人的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="36-map遍历"><a class="markdownIt-Anchor" href="#36-map遍历"></a> 3.6. map遍历</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">        <span class="string">&quot;a&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;b&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;c&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;k地址: %p, v地址: %p\n&quot;</span>, &amp;k, &amp;v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// k和v的地址也是固定的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>场景 陷阱原因 解决方案<br />
指针切片 所有指针指向同一地址 创建临时变量或使用索引<br />
闭包 捕获变量地址而非值 传参或创建副本<br />
goroutine 并发访问同一变量 传参给goroutine<br />
结构体 取迭代变量地址 使用索引取原切片元素地址</p>
<p>最佳实践：在 for range 循环中需要使用地址或闭包时，务必创建临时变量或使用索引直接访问原数据。</p>
<h1 id="4-go-defer多个-defer-的顺序defer-在什么时机会修改返回值for-defer"><a class="markdownIt-Anchor" href="#4-go-defer多个-defer-的顺序defer-在什么时机会修改返回值for-defer"></a> 4、go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？（for defer）</h1>
<p>defer recover 的问题？(主要是能不能捕获)</p>
<h2 id="41-defer基本原理"><a class="markdownIt-Anchor" href="#41-defer基本原理"></a> 4.1 defer基本原理</h2>
<pre><code>defer语句将会函数调用推入到一个栈中，函数返回时按照后进先出（LIFO）顺序执行这些推入的函数。
</code></pre>
<h2 id="42-多个defer的执行顺序"><a class="markdownIt-Anchor" href="#42-多个defer的执行顺序"></a> 4.2 多个defer的执行顺序</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;First defer&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Second defer&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Third defer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出顺序： Third defer， Second defer ， First defer</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>for循环中的defer</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> deferInLoop()&#123;</span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++&#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 输出顺序：4 3 2 1 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>注意事项</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误示例：defer在循环中累积</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFiles</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        f, _ := os.Open(fmt.Sprintf(<span class="string">&quot;file%d.txt&quot;</span>, i))</span><br><span class="line">        <span class="keyword">defer</span> f.Close() <span class="comment">// 所有Close都会累积，文件不会及时关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 函数结束时才执行所有defer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确做法：使用匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFiles</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            f, _ := os.Open(fmt.Sprintf(<span class="string">&quot;file%d.txt&quot;</span>, i))</span><br><span class="line">            <span class="keyword">defer</span> f.Close() <span class="comment">// 每次循环结束时执行</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="43-defer修改返回值的时机"><a class="markdownIt-Anchor" href="#43-defer修改返回值的时机"></a> 4.3 defer修改返回值的时机</h2>
<p>关键点: defer在return语句执行之后，函数真正返回之前执行。因此，如果defer函数修改了命名返回值，则会影响最终返回值。<br />
函数返回过程：<br />
1、给返回值赋值<br />
2、执行defer语句 （可以修改返回值）<br />
3、函数返回</p>
<h3 id="431-命名返回值示例"><a class="markdownIt-Anchor" href="#431-命名返回值示例"></a> 4.3.1 命名返回值示例</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(result <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        result += <span class="number">5</span>  <span class="comment">// 修改命名返回值</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>  <span class="comment">// 第一步：result = 10</span></span><br><span class="line">&#125; <span class="comment">// 第二步：执行defer，result变为15，第三步：返回15</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="432-匿名返回值示例"><a class="markdownIt-Anchor" href="#432-匿名返回值示例"></a> 4.3.2 匿名返回值示例</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="type">int</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        result += <span class="number">5</span>  <span class="comment">// 修改局部变量，不影响返回值</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>  <span class="comment">// 返回值 = result (0), defer修改的是局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终返回10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="433-返回指针引用类型-defer-可以修改"><a class="markdownIt-Anchor" href="#433-返回指针引用类型-defer-可以修改"></a> 4.3.3 返回指针/引用类型 - defer 可以修改</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span></span> *<span class="type">int</span>&#123;</span><br><span class="line"></span><br><span class="line">    result :=<span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        result +=<span class="number">5</span>  <span class="comment">// 修改局部变量,修改指针指向的值</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> &amp;result  <span class="comment">// 返回指针，defer修改了指针指向的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终返回指向5的指针, 返回*int 值为5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-defer的参数求值时机"><a class="markdownIt-Anchor" href="#4-defer的参数求值时机"></a> 4 defer的参数求值时机</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferArgs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    x := <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer x:&quot;</span>, x) <span class="comment">// 参数在defer时求值</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x:&quot;</span>, x) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：0（不是1）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferClosure</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i :=<span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;defer i:&quot;</span>,i) <span class="comment">// 闭包捕获变量，延迟执行时使用最新值</span></span><br><span class="line">    &#125;()</span><br><span class="line">    i ++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>避免在 for 循环中直接使用 defer（除非有意为之）<br />
需要修改返回值时，使用命名返回值<br />
defer 参数会立即求值，使用闭包捕获变量</p>
<h1 id="5-uint-类型溢出"><a class="markdownIt-Anchor" href="#5-uint-类型溢出"></a> 5、uint 类型溢出</h1>
<h2 id="51-基本概念"><a class="markdownIt-Anchor" href="#51-基本概念"></a> 5.1 基本概念</h2>
<pre><code>在go语言中，uint是一种无符号整数类型，表示非负整数。它的大小依赖于具体的实现，通常是32位或64位。uint类型的取值范围是从0到2^n - 1，其中n是uint的位数（32或64）。
</code></pre>
<p>uint类型返回</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint8:  0 ~ 255 (2^8 - 1)</span><br><span class="line">uint16: 0 ~ 65535 (2^16 - 1)</span><br><span class="line">uint32: 0 ~ 4294967295 (2^32 - 1)</span><br><span class="line">uint64: 0 ~ 18446744073709551615 (2^64 - 1)</span><br><span class="line">uint:   取决于平台（32位或64位）</span><br></pre></td></tr></table></figure>
<h2 id="52-溢出行为"><a class="markdownIt-Anchor" href="#52-溢出行为"></a> 5.2 溢出行为</h2>
<pre><code>当对uint类型进行运算时，如果结果超出了其表示范围，就会发生溢出。溢出的结果会“环绕”回到最小值。例如，对于uint8类型，如果执行以下操作：
</code></pre>
<ul>
<li>上溢，超过最大值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">uint8</span> = <span class="number">255</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;原始值: %d\n&quot;</span>, a)</span><br><span class="line">    </span><br><span class="line">    a = a + <span class="number">1</span>  <span class="comment">// 溢出，变为 0</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;255 + 1 = %d\n&quot;</span>, a)</span><br><span class="line">    </span><br><span class="line">    a = <span class="number">255</span> + <span class="number">2</span>  <span class="comment">// 溢出，变为 1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;255 + 2 = %d\n&quot;</span>, a)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出:</span></span><br><span class="line">    <span class="comment">// 原始值: 255</span></span><br><span class="line">    <span class="comment">// 255 + 1 = 0</span></span><br><span class="line">    <span class="comment">// 255 + 2 = 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>下溢，低于最小值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b <span class="type">uint8</span> = <span class="number">0</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;原始值: %d\n&quot;</span>, b)</span><br><span class="line">    </span><br><span class="line">    b = b - <span class="number">1</span>  <span class="comment">// 下溢，变为 255</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;0 - 1 = %d\n&quot;</span>, b)</span><br><span class="line">    </span><br><span class="line">    b = <span class="number">0</span> - <span class="number">5</span>  <span class="comment">// 下溢，变为 251</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;0 - 5 = %d\n&quot;</span>, b)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出:</span></span><br><span class="line">    <span class="comment">// 原始值: 0</span></span><br><span class="line">    <span class="comment">// 0 - 1 = 255</span></span><br><span class="line">    <span class="comment">// 0 - 5 = 251</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="53-实际场景"><a class="markdownIt-Anchor" href="#53-实际场景"></a> 5.3 实际场景</h2>
<ul>
<li>计数器：使用uint类型作为计数器时，需注意溢出问题，避免出现负数。</li>
<li>内存大小：表示内存大小时，使用uint类型可以避免负值，但需防止溢出。</li>
<li>位运算：在进行位运算时，需确保结果在uint类型范围内。</li>
<li>数组索引：使用uint类型作为数组索引时，需确保索引值不会溢出。</li>
<li>循环控制：在循环中使用uint类型作为循环变量时，需注意循环条件，防止溢出导致无限循环。</li>
<li>时间计算：在进行时间计算时，使用uint类型表示时间戳或持续时间时，需防止溢出。</li>
<li>网络编程：在处理网络数据包大小时，使用uint类型表示数据包长度时，需防止溢出。</li>
<li>文件大小：在处理文件大小时，使用uint类型表示文件大小时，需防止溢出。</li>
<li>图像处理：在处理图像像素值时，使用uint类型表示像素值时，需防止溢出。</li>
<li>加密算法：在实现加密算法时，使用uint类型表示密钥或数据块时，需防止溢出。</li>
<li>游戏开发：在游戏开发中，使用uint类型表示分数或生命值时，需防止溢出。</li>
</ul>
<h2 id="54-防止溢出的方法"><a class="markdownIt-Anchor" href="#54-防止溢出的方法"></a> 5.4 防止溢出的方法</h2>
<ul>
<li>使用更大类型：如果预期值可能超过当前uint类型的范围，可以使用更大位数的uint类型（如uint64）。</li>
<li>检查边界条件：在进行运算前，检查操作数是否会导致溢出。</li>
<li>使用第三方库：一些第三方库提供了安全的整数类型，可以自动处理溢出问题。</li>
</ul>
<p>使用 math/bits 包</p>
<p>注意事项<br />
Go不会抛出溢出异常，需要手动检测<br />
编译器不会警告溢出（除非使用工具如go vet）<br />
溢出行为是确定的，遵循二进制补码规则<br />
不同于其他语言，如Python会自动转换为大整数<br />
性能考虑：溢出检查会增加开销，按需使用</p>
<h1 id="6-介绍-rune-类型"><a class="markdownIt-Anchor" href="#6-介绍-rune-类型"></a> 6、介绍 rune 类型</h1>
<h2 id="61-基本概念"><a class="markdownIt-Anchor" href="#61-基本概念"></a> 6.1 基本概念</h2>
<pre><code>在Go语言中，rune是一个内置的数据类型，实际上是int32的别名。它用于表示Unicode代码点，即一个字符在Unicode标准中的唯一标识符。rune类型可以表示所有的Unicode字符，包括ASCII字符和非ASCII字符。
</code></pre>
<h2 id="62-rune与字符的关系"><a class="markdownIt-Anchor" href="#62-rune与字符的关系"></a> 6.2 rune与字符的关系</h2>
<pre><code>在Go中，字符是以rune类型表示的。每个rune值对应一个Unicode代码点。例如，字符'a'的rune值是97，因为97是Unicode中'a'的代码点。
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> r <span class="type">rune</span> = <span class="string">&#x27;a&#x27;</span> <span class="comment">// r的值是97</span></span><br></pre></td></tr></table></figure>
<h2 id="63-rune与字符串的关系"><a class="markdownIt-Anchor" href="#63-rune与字符串的关系"></a> 6.3 rune与字符串的关系</h2>
<pre><code>字符串是由一系列rune组成的序列。在Go中，字符串是不可变的字节序列，而rune则表示字符串中的单个字符。可以通过将字符串转换为rune切片来访问字符串中的每个字符。
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s := <span class="string">&quot;Hello, 世界&quot;</span></span><br><span class="line">runes := []<span class="type">rune</span>(s) <span class="comment">// 将字符串转换为rune切片</span></span><br><span class="line">fmt.Println(runes) <span class="comment">// 输出: [72 101 108 108 111 44 32 19990 30028]</span></span><br></pre></td></tr></table></figure>
<h2 id="64-rune的使用场景"><a class="markdownIt-Anchor" href="#64-rune的使用场景"></a> 6.4 rune的使用场景</h2>
<ul>
<li>处理Unicode字符：rune类型可以表示所有Unicode字符，适用于需要处理多语言文本的场景。</li>
<li>字符串遍历：使用rune切片可以方便地遍历字符串中的每个字符，尤其是包含非ASCII字符的字符串。</li>
<li>字符操作：可以对rune进行各种字符操作，如转换大小写、判断字符类型等。</li>
<li>字符编码转换：在处理不同字符编码时，rune可以作为中间表示，方便进行转换。</li>
<li>正则表达式：在使用正则表达式时，rune可以用于匹配Unicode字符。</li>
<li>文本处理：在文本处理任务中，rune可以用于分词、拼写检查等操作。</li>
<li>输入法开发：在开发输入法时，rune可以用于表示用户输入的字符。</li>
<li>编译器设计：在编译器中，rune可以用于表示源代码中的字符。</li>
</ul>
<h2 id="7性能考虑"><a class="markdownIt-Anchor" href="#7性能考虑"></a> 7性能考虑</h2>
<p>1.[] rune转换开销</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;这是一个很长的中文字符串&quot;</span> + <span class="string">&quot;重复很多次&quot;</span></span><br><span class="line">    longString := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        longString += s</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式1: 多次转换 (慢)</span></span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        runes := []<span class="type">rune</span>(longString)  <span class="comment">// 每次都转换</span></span><br><span class="line">        _ = <span class="built_in">len</span>(runes)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;多次转换耗时: %v\n&quot;</span>, time.Since(start))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式2: 转换一次 (快)</span></span><br><span class="line">    start = time.Now()</span><br><span class="line">    runes := []<span class="type">rune</span>(longString)  <span class="comment">// 只转换一次</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        _ = <span class="built_in">len</span>(runes)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;转换一次耗时: %v\n&quot;</span>, time.Since(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.使用strings.builder</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildStringWithRunes</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> builder strings.Builder</span><br><span class="line">    runes := []<span class="type">rune</span>&#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;世&#x27;</span>, <span class="string">&#x27;界&#x27;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> runes &#123;</span><br><span class="line">        builder.WriteRune(r)  <span class="comment">// 高效写入rune</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result := buildStringWithRunes()</span><br><span class="line">    fmt.Println(result)  <span class="comment">// Hello世界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最佳实践<br />
处理非ASCII字符串时使用rune<br />
避免频繁的string和[]rune转换<br />
使用range遍历字符串获取rune<br />
使用utf8包进行底层操作<br />
注意string索引操作的是字节而非字符</p>
<h1 id="7-golang-中解析-tag-是怎么实现的反射原理是什么问的很少但是代码中用的多"><a class="markdownIt-Anchor" href="#7-golang-中解析-tag-是怎么实现的反射原理是什么问的很少但是代码中用的多"></a> 7、 golang 中解析 tag 是怎么实现的？反射原理是什么？(问的很少，但是代码中用的多)</h1>
<h2 id="71-struct-tag-是什么为什么能被解析"><a class="markdownIt-Anchor" href="#71-struct-tag-是什么为什么能被解析"></a> 7.1 struct tag 是什么？为什么能被解析？</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID    <span class="type">int</span>    <span class="string">`json:&quot;id&quot; db:&quot;user_id&quot;`</span></span><br><span class="line">    Name  <span class="type">string</span> <span class="string">`json:&quot;name,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>tag的本质</li>
</ul>
<blockquote>
<p>👉 tag 是 struct 字段在编译期就写入的字符串元数据<br />
👉 tag 存储在类型信息中，可以通过反射访问<br />
它不是运行时生成的猫也不是map，本质就是<br />
Field.Tag == <code>json:&quot;id&quot; db:&quot;user_id&quot;</code></p>
</blockquote>
<h2 id="72-go是怎么解析tag的"><a class="markdownIt-Anchor" href="#72-go是怎么解析tag的"></a> 7.2 Go是怎么解析tag的？</h2>
<ul>
<li>反射入口</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(User&#123;&#125;)</span><br><span class="line">field, ok := t.FieldByName(<span class="string">&quot;ID&quot;</span>)</span><br><span class="line">fmt.Println(field.Tag) <span class="comment">// 输出: `json:&quot;id&quot; db:&quot;user_id&quot;`</span></span><br></pre></td></tr></table></figure>
<ul>
<li>StructTag的定义</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># reflect/<span class="keyword">type</span>.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">typr StructTag <span class="type">string</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>也就是数tag就是一个字符换，没有任何的数据结构</p>
</blockquote>
<ul>
<li>Get() 是怎么是实现的？</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value := field.Tag.Get(<span class="string">&quot;json&quot;</span>) <span class="comment">// &quot;id&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关键的结论：<br />
tag不是mao，它只是一个字符串<br />
是运行时用字符串操作来解析的<br />
格式要求非常的严格：key:“value”</p>
</blockquote>
<p>面试题解析<br />
Go 的 struct tag 是编译期写入的字符串元数据，运行时通过反射从类型描述信息中读取，<br />
reflect.StructTag 本质只是字符串，通过扫描解析 key:“value” 格式。<br />
反射的底层原理是runtime 保存了完整的类型元信息（rtype），reflect.Type / Value 只是这些元数据的安全封装。</p>
<blockquote>
<blockquote>
<p>反射 = 运行时读取编译期生成的类型描述信息（runtime type metadata）</p>
</blockquote>
</blockquote>
<h1 id="8-调用函数传入结构体时应该传值还是指针"><a class="markdownIt-Anchor" href="#8-调用函数传入结构体时应该传值还是指针"></a> 8、调用函数传入结构体时，应该传值还是指针？</h1>
<p>结论</p>
<blockquote>
<p>默认传指针，只有在明确不需要指针才传值</p>
</blockquote>
<h2 id="81-go里面只有值传递那为什么还有指针"><a class="markdownIt-Anchor" href="#81-go里面只有值传递那为什么还有指针"></a> 8.1 Go里面只有值传递，那为什么还有指针？</h2>
<p>首先明显一件事，Go语言中所有的函数调用都是值传递，这意味着当你将一个变量传递给函数时，函数接收到的是该变量的一个副本。然而，当我们谈论传递结构体时，传递指针实际上是传递了结构体在内存中的地址，这样做有几个重要的好处：</p>
<ol>
<li><strong>性能优化</strong>：结构体可能包含大量数据，传递整个结构体会涉及到数据的复制，这在性能上是昂贵的。通过传递指针，只需复制地址（通常是4或8字节），大大减少了内存开销和复制时间。</li>
<li><strong>修改原始数据</strong>：当你传递结构体的指针时，函数可以直接修改原始结构体的数据，而不是其副本。这对于需要在函数中更新结构体状态的场景非常有用。</li>
<li><strong>避免栈溢出</strong>：对于非常大的结构体，传递值可能会导致栈空间不足，从而引发栈溢出错误。传递指针可以避免这种风险。</li>
<li><strong>一致性和习惯用法</strong>：在Go社区中，传递指针是处理结构体的常见做法，这有助于保持代码的一致性和可读性。</li>
</ol>
<h2 id="82-什么时候一定要传指针"><a class="markdownIt-Anchor" href="#82-什么时候一定要传指针"></a> 8.2 什么时候一定要传指针？</h2>
<h3 id="821-函数需要修改结构体最重要"><a class="markdownIt-Anchor" href="#821-函数需要修改结构体最重要"></a> 8.2.1 函数需要修改结构体（最重要）</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateUserName</span><span class="params">(u *User, newName <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    u.Name = newName <span class="comment">// 直接修改原始结构体</span></span><br><span class="line">&#125; </span><br><span class="line">#  如果你传值的话，修改不会反映到调用者</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateUserNameValue</span><span class="params">(u User, newName <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    u.Name = newName <span class="comment">// 修改的是副本</span></span><br><span class="line">&#125; </span><br><span class="line"># 修改必须是指针</span><br></pre></td></tr></table></figure>
<h3 id="822-结构体较大"><a class="markdownIt-Anchor" href="#822-结构体较大"></a> 8.2.2 结构体较大</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Big <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data [<span class="number">1024</span> * <span class="number">1024</span>]<span class="type">byte</span> <span class="comment">// 1MB数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>传值：每次拷贝1kb</li>
<li>传指针：只拷贝8字节地址</li>
</ul>
<p>struct ≥ 几十字节 → 优先指针<br />
struct 含大数组 / map / slice / string → 几乎一定指针</p>
<h3 id="823-需要保持语义一致性"><a class="markdownIt-Anchor" href="#823-需要保持语义一致性"></a> 8.2.3 需要保持语义一致性</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> Save() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(u User)</span></span> &#123;</span><br><span class="line">    u.Save() <span class="comment">// ❌ 编译不过</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#User 的 method set 不包含 *User 的方法</span><br><span class="line">#反过来可以（编译器自动取地址）</span><br></pre></td></tr></table></figure>
<h3 id="824-避免拷贝导致的隐藏-bug"><a class="markdownIt-Anchor" href="#824-避免拷贝导致的隐藏-bug"></a> 8.2.4 避免拷贝导致的“隐藏 Bug”</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Options <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Modify</span><span class="params">(c Config)</span></span> &#123;</span><br><span class="line">    c.Options[<span class="string">&quot;x&quot;</span>] = <span class="string">&quot;y&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># ⚠️ 这会修改原 <span class="keyword">map</span>！</span><br><span class="line">因为：</span><br><span class="line">    <span class="keyword">struct</span> 被拷贝</span><br><span class="line">    <span class="keyword">map</span> 是引用类型</span><br><span class="line">    修改 <span class="keyword">map</span> 内容会影响原对象</span><br><span class="line">    👉 这种“半拷贝”行为非常容易误导</span><br><span class="line">    ✔ 用指针，语义更清晰</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="83-什么时候传值"><a class="markdownIt-Anchor" href="#83-什么时候传值"></a> 8.3 什么时候传值？</h1>
<h3 id="831-结构体很小-不可变语义"><a class="markdownIt-Anchor" href="#831-结构体很小-不可变语义"></a> 8.3.1 结构体很小 + 不可变语义</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Distance</span><span class="params">(a, b Point)</span></span> <span class="type">float64</span></span><br><span class="line"></span><br><span class="line">✔ 小</span><br><span class="line">✔ 不修改</span><br><span class="line">✔ 数学/值对象</span><br><span class="line"></span><br><span class="line">👉 传值更清晰</span><br></pre></td></tr></table></figure>
<h3 id="832-只读场景-明确不修改"><a class="markdownIt-Anchor" href="#832-只读场景-明确不修改"></a> 8.3.2 只读场景 + 明确不修改</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintUser</span><span class="params">(u User)</span></span> &#123;</span><br><span class="line">    fmt.Println(u.Name)</span><br><span class="line">&#125;</span><br><span class="line">✔ 不修改</span><br><span class="line">✔ 只读</span><br><span class="line">👉 传值更安全</span><br></pre></td></tr></table></figure>
<h3 id="833-避免-nil稳定性"><a class="markdownIt-Anchor" href="#833-避免-nil稳定性"></a> 8.3.3 避免 nil（稳定性）</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(u User)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(u *User)</span></span> <span class="comment">// 可能 panic</span></span><br><span class="line"></span><br><span class="line">如果函数逻辑不能接受 <span class="literal">nil</span>：</span><br><span class="line"></span><br><span class="line">✔ 用值</span><br><span class="line">❌ 不要强迫调用方构造指针</span><br></pre></td></tr></table></figure>
<h2 id="834-高并发-不希望共享状态"><a class="markdownIt-Anchor" href="#834-高并发-不希望共享状态"></a> 8.3.4 高并发 / 不希望共享状态</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(req Request)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(req *Request)</span></span></span><br><span class="line"></span><br><span class="line">那就要开始担心：</span><br><span class="line">    数据竞争</span><br><span class="line">    隐式共享</span><br><span class="line">goroutine 安全</span><br><span class="line"></span><br><span class="line">👉 值传递天然隔离</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3>
<p>状态型对象 → 指针<br />
值对象 / DTO / 参数对象 → 值</p>
<h1 id="9-silce-遇到过哪些问题"><a class="markdownIt-Anchor" href="#9-silce-遇到过哪些问题"></a> 9. silce 遇到过哪些问题？</h1>
<h2 id="91-append-导致对的数据悄悄被改掉"><a class="markdownIt-Anchor" href="#91-append-导致对的数据悄悄被改掉"></a> 9.1 append 导致对的数据悄悄被改掉</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b := a[:<span class="number">2</span>]          <span class="comment">// b = [1 2]</span></span><br><span class="line"></span><br><span class="line">b = <span class="built_in">append</span>(b,<span class="number">100</span>) <span class="comment">// b = [1 2 100], 可能修改了 a 底层数组</span></span><br><span class="line">fmt.Println(a) <span class="comment">// 可能输出 [1 2 100]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a 和 b 共享底层数组</span><br><span class="line">b <span class="built_in">append</span> 时 容量够用</span><br><span class="line">覆盖了 a[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>修复方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">b := <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), a[:<span class="number">2</span>]...) <span class="comment">// 复制一份数据</span></span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">b := slice.Clone(a[:<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<h2 id="92-for-range-append-导致死循环逻辑错误"><a class="markdownIt-Anchor" href="#92-for-range-append-导致死循环逻辑错误"></a> 9.2 for range + append 导致死循环/逻辑错误</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">    <span class="keyword">if</span> someCondition(v) &#123;</span><br><span class="line">        slice = <span class="built_in">append</span>(slice, newValue) <span class="comment">// 修改了 slice 导致死循环或逻辑错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- 根本原因</span><br><span class="line">    <span class="keyword">range</span> 在循环开始时就固定了 <span class="built_in">len</span></span><br><span class="line">    <span class="built_in">append</span> 修改的是同一个 slice</span><br><span class="line">    逻辑极其容易出错</span><br><span class="line"></span><br><span class="line"># ❌ 不要在 <span class="keyword">range</span> 原 slice 时 <span class="built_in">append</span> 同一个 slice</span><br></pre></td></tr></table></figure>
<h1 id="93-sub-slice-导致数据泄漏"><a class="markdownIt-Anchor" href="#93-sub-slice-导致数据泄漏"></a> 9.3 sub-slice 导致数据泄漏;</h1>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10</span> &lt;&lt; <span class="number">20</span>) <span class="comment">// 10MB 大缓冲区</span></span><br><span class="line">small := buf[:<span class="number">1024</span>]          <span class="comment">// 1KB 小切片</span></span><br><span class="line"><span class="keyword">return</span> small  <span class="comment">// 返回 small 导致 buf 无法被 GC 回收</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 问题</span><br><span class="line">    small 只用 <span class="number">100</span>B</span><br><span class="line">    但 引用了 <span class="number">10</span>MB 的底层数组</span><br><span class="line">GC 不会回收</span><br><span class="line">📌 这是 Go 服务内存暴涨的经典原因</span><br><span class="line"></span><br><span class="line"># 解决方法</span><br><span class="line">small := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">copy</span>(small, buf[:<span class="number">100</span>]) <span class="comment">// 复制数据，断开引用</span></span><br></pre></td></tr></table></figure>
<h1 id="94-append-过程中slice失效指针悬空"><a class="markdownIt-Anchor" href="#94-append-过程中slice失效指针悬空"></a> 9.4 append 过程中slice失效（指针悬空）</h1>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">p := &amp;s[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>) <span class="comment">// 触发扩容</span></span><br><span class="line"></span><br><span class="line">fmt.Println(*p) <span class="comment">// ❌ 未定义行为</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>原因</p>
<ul>
<li>append 可能触发 重新分配</li>
<li>原地址失效</li>
<li>指针变成“悬空指针”<br />
📌 禁止保存 slice 元素指针并 append</li>
</ul>
<h1 id="96-并发读写slice-导致数据竞态"><a class="markdownIt-Anchor" href="#96-并发读写slice-导致数据竞态"></a> 9.6 并发读写Slice 导致数据竞态</h1>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">   s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">   fmt.Println(s[<span class="number">0</span>])</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题</span><br><span class="line">    slice 不是线程安全的</span><br><span class="line">    <span class="built_in">append</span> 涉及：</span><br><span class="line">    <span class="built_in">len</span></span><br><span class="line">    <span class="built_in">cap</span></span><br><span class="line">底层数组写入</span><br><span class="line">📌 这是 data race + <span class="built_in">panic</span> 双重风险</span><br></pre></td></tr></table></figure>
<h1 id="98-make-参数理解错误"><a class="markdownIt-Anchor" href="#98-make-参数理解错误"></a> 9.8 make 参数理解错误</h1>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">5</span>)</span><br><span class="line">a = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">fmt.Println(s) <span class="comment">// [0 0 0 0 0 1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 正确预分配</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h1 id="910-删除元素写错"><a class="markdownIt-Anchor" href="#910-删除元素写错"></a> 9.10、删除元素写错</h1>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s := <span class="built_in">append</span>(s[:i], s[i+<span class="number">1</span>:]...) <span class="comment">// 删除索引 i 元素</span></span><br><span class="line"></span><br><span class="line">隐藏问题</span><br><span class="line">    底层数组仍然持有 s[i]</span><br><span class="line">    对大对象 → GC 无法回收</span><br><span class="line"></span><br><span class="line"># 安全删除</span><br><span class="line"><span class="built_in">copy</span>(s[i:], s[i+<span class="number">1</span>:])</span><br><span class="line">s[<span class="built_in">len</span>(s)<span class="number">-1</span>] = zeroValue</span><br><span class="line">s = s[:<span class="built_in">len</span>(s)<span class="number">-1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="911-总结"><a class="markdownIt-Anchor" href="#911-总结"></a> 9.11. 总结</h1>
<p>slice 三大核心认知</p>
<p>1️⃣ slice = header + 底层数组<br />
2️⃣ sub-slice 默认共享内存<br />
3️⃣ append 是否扩容决定一切</p>
<p>一句话工程原则<br />
谁创建，谁负责扩容；<br />
谁持有，谁避免共享。</p>
<h1 id="10-go-struct-能不能比较"><a class="markdownIt-Anchor" href="#10-go-struct-能不能比较"></a> 10. go struct 能不能比较？</h1>
<h1 id="11-go-闭包"><a class="markdownIt-Anchor" href="#11-go-闭包"></a> 11. Go 闭包</h1>
<h1 id="10-go-struct-能不能比较-2"><a class="markdownIt-Anchor" href="#10-go-struct-能不能比较-2"></a> 10. go struct 能不能比较？</h1>
<h2 id="101-基本规则"><a class="markdownIt-Anchor" href="#101-基本规则"></a> 10.1 基本规则</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 可以比较的情况</span></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">int</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不能比较的情况</span></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>  <span class="comment">// map不能比较</span></span><br><span class="line">    s []<span class="type">int</span>          <span class="comment">// slice不能比较</span></span><br><span class="line">    f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>         <span class="comment">// 函数不能比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="102-比较规则详解"><a class="markdownIt-Anchor" href="#102-比较规则详解"></a> 10.2 比较规则详解</h2>
<table>
<thead>
<tr>
<th>结构体字段类型</th>
<th>是否可比较</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本类型(int, string等)</td>
<td>✅</td>
<td>直接比较值</td>
</tr>
<tr>
<td>指针</td>
<td>✅</td>
<td>比较指针地址</td>
</tr>
<tr>
<td>数组</td>
<td>✅</td>
<td>逐元素比较</td>
</tr>
<tr>
<td>结构体</td>
<td>✅</td>
<td>递归比较字段</td>
</tr>
<tr>
<td>slice</td>
<td>❌</td>
<td>引用类型，不可比较</td>
</tr>
<tr>
<td>map</td>
<td>❌</td>
<td>引用类型，不可比较</td>
</tr>
<tr>
<td>channel</td>
<td>✅</td>
<td>比较channel地址</td>
</tr>
<tr>
<td>interface</td>
<td>✅</td>
<td>比较类型和值</td>
</tr>
<tr>
<td>函数</td>
<td>❌</td>
<td>函数不可比较</td>
</tr>
</tbody>
</table>
<h2 id="103-实际示例"><a class="markdownIt-Anchor" href="#103-实际示例"></a> 10.3 实际示例</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 完全可比较的结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 包含不可比较字段的结构体</span></span><br><span class="line"><span class="keyword">type</span> Container <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data []<span class="type">int</span>  <span class="comment">// slice不可比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := Person&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;</span><br><span class="line">    p2 := Person&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;</span><br><span class="line">    p3 := Person&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>&#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(p1 == p2) <span class="comment">// true</span></span><br><span class="line">    fmt.Println(p1 == p3) <span class="comment">// false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// c1 := Container&#123;[]int&#123;1, 2&#125;&#125;</span></span><br><span class="line">    <span class="comment">// c2 := Container&#123;[]int&#123;1, 2&#125;&#125;</span></span><br><span class="line">    <span class="comment">// fmt.Println(c1 == c2) // 编译错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="104-特殊情况"><a class="markdownIt-Anchor" href="#104-特殊情况"></a> 10.4 特殊情况</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空结构体比较</span></span><br><span class="line"><span class="keyword">type</span> Empty <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> e1, e2 Empty</span><br><span class="line">    fmt.Println(e1 == e2) <span class="comment">// true，所有空结构体都相等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含nil指针</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="type">int</span></span><br><span class="line">    next  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n1 := Node&#123;<span class="number">1</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    n2 := Node&#123;<span class="number">1</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    fmt.Println(n1 == n2) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="105-最佳实践"><a class="markdownIt-Anchor" href="#105-最佳实践"></a> 10.5 最佳实践</h2>
<ol>
<li><strong>设计可比较结构体</strong>：避免slice、map、func字段</li>
<li><strong>使用自定义比较</strong>：对于复杂结构体实现Equal()方法</li>
<li><strong>注意nil值</strong>：指针类型的nil值比较</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义比较方法</span></span><br><span class="line"><span class="keyword">type</span> ComplexData <span class="keyword">struct</span> &#123;</span><br><span class="line">    items []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ComplexData)</span></span> Equal(other *ComplexData) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(c.items) != <span class="built_in">len</span>(other.items) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> c.items &#123;</span><br><span class="line">        <span class="keyword">if</span> v != other.items[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="11-go-闭包-2"><a class="markdownIt-Anchor" href="#11-go-闭包-2"></a> 11. Go 闭包</h1>
<h2 id="111-什么是闭包"><a class="markdownIt-Anchor" href="#111-什么是闭包"></a> 11.1 什么是闭包？</h2>
<p>闭包是一个函数值，它引用了函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，这些变量被&quot;封闭&quot;在该函数中。</p>
<h2 id="112-闭包的基本特性"><a class="markdownIt-Anchor" href="#112-闭包的基本特性"></a> 11.2 闭包的基本特性</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 基本闭包示例</span></span><br><span class="line">    x := <span class="number">10</span></span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">1</span>  <span class="comment">// 捕获外部变量x</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(f()) <span class="comment">// 11</span></span><br><span class="line">    x = <span class="number">20</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// 21 - 闭包引用的是变量x本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="113-闭包的常见陷阱"><a class="markdownIt-Anchor" href="#113-闭包的常见陷阱"></a> 11.3 闭包的常见陷阱</h2>
<h3 id="1131-循环变量陷阱"><a class="markdownIt-Anchor" href="#1131-循环变量陷阱"></a> 11.3.1 循环变量陷阱</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> funcs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        funcs = <span class="built_in">append</span>(funcs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(i) <span class="comment">// 所有函数都输出3</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">        f() <span class="comment">// 输出: 3 3 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确做法1：传参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> funcs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        funcs = <span class="built_in">append</span>(funcs, <span class="function"><span class="keyword">func</span><span class="params">(val <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                fmt.Println(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)) <span class="comment">// 立即执行，传入i的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">        f() <span class="comment">// 输出: 0 1 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确做法2：创建局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> funcs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        i := i <span class="comment">// Go 1.22之前需要这样</span></span><br><span class="line">        funcs = <span class="built_in">append</span>(funcs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">        f() <span class="comment">// 输出: 0 1 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1132-goroutine闭包陷阱"><a class="markdownIt-Anchor" href="#1132-goroutine闭包陷阱"></a> 11.3.2 goroutine闭包陷阱</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(v) <span class="comment">// 可能输出多个5</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确做法：传参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(val <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(val) <span class="comment">// 输出1 2 3 4 5（顺序不定）</span></span><br><span class="line">        &#125;(v)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="114-闭包的实际应用"><a class="markdownIt-Anchor" href="#114-闭包的实际应用"></a> 11.4 闭包的实际应用</h2>
<h3 id="1141-函数工厂"><a class="markdownIt-Anchor" href="#1141-函数工厂"></a> 11.4.1 函数工厂</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加法器工厂</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeAdder</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    add5 := makeAdder(<span class="number">5</span>)</span><br><span class="line">    add10 := makeAdder(<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(add5(<span class="number">3</span>))  <span class="comment">// 8</span></span><br><span class="line">    fmt.Println(add10(<span class="number">3</span>)) <span class="comment">// 13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1142-装饰器模式"><a class="markdownIt-Anchor" href="#1142-装饰器模式"></a> 11.4.2 装饰器模式</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日志装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withLogging</span><span class="params">(f <span class="keyword">func</span>(<span class="type">int</span>)</span></span>) <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;调用函数，参数: %d\n&quot;</span>, x)</span><br><span class="line">        f(x)</span><br><span class="line">        fmt.Println(<span class="string">&quot;函数调用完成&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;处理: %d\n&quot;</span>, x * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    decorated := withLogging(process)</span><br><span class="line">    decorated(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1143-延迟计算"><a class="markdownIt-Anchor" href="#1143-延迟计算"></a> 11.4.3 延迟计算</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟计算斐波那契数列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        result := a</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fib := fibonacci()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(fib())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="115-闭包与内存管理"><a class="markdownIt-Anchor" href="#115-闭包与内存管理"></a> 11.5 闭包与内存管理</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包可能导致内存泄漏</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">leakyFunction</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>) <span class="comment">// 1MB数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">len</span>(data)) <span class="comment">// 闭包持有data引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := leakyFunction()</span><br><span class="line">    f() <span class="comment">// data不会被GC回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="116-闭包的最佳实践"><a class="markdownIt-Anchor" href="#116-闭包的最佳实践"></a> 11.6 闭包的最佳实践</h2>
<ol>
<li><strong>避免循环变量陷阱</strong>：使用传参或局部变量</li>
<li><strong>注意内存泄漏</strong>：闭包会延长对象生命周期</li>
<li><strong>合理使用闭包</strong>：在需要状态保持时使用</li>
<li><strong>理解闭包本质</strong>：闭包=函数+引用的环境</li>
</ol>
<h1 id="12-context"><a class="markdownIt-Anchor" href="#12-context"></a> 12. Context</h1>
<h2 id="121-context-结构是什么样的"><a class="markdownIt-Anchor" href="#121-context-结构是什么样的"></a> 12.1、context 结构是什么样的？</h2>
<h3 id="1211-context接口定义"><a class="markdownIt-Anchor" href="#1211-context接口定义"></a> 12.1.1 Context接口定义</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Deadline 返回context应该被取消的时间</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Done 返回一个channel，当context被取消时关闭</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Err 返回context被取消的原因</span></span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Value 返回context中与key关联的值</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1212-context的继承结构"><a class="markdownIt-Anchor" href="#1212-context的继承结构"></a> 12.1.2 Context的继承结构</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空context - 所有context的根</span></span><br><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可取消的context</span></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    err  <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带超时的context</span></span><br><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    cancelCtx</span><br><span class="line">    timer *time.Timer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带值的context</span></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="122-context-使用场景和用途基本必问"><a class="markdownIt-Anchor" href="#122-context-使用场景和用途基本必问"></a> 12.2、context 使用场景和用途？（基本必问）</h2>
<h3 id="1221-主要使用场景"><a class="markdownIt-Anchor" href="#1221-主要使用场景"></a> 12.2.1 主要使用场景</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP请求</td>
<td>传递请求ID、用户信息</td>
<td><code>req.Context()</code></td>
</tr>
<tr>
<td>数据库操作</td>
<td>设置查询超时</td>
<td><code>context.WithTimeout()</code></td>
</tr>
<tr>
<td>微服务调用</td>
<td>传递链路追踪信息</td>
<td><code>context.WithValue()</code></td>
</tr>
<tr>
<td>后台任务</td>
<td>优雅关闭</td>
<td><code>context.WithCancel()</code></td>
</tr>
</tbody>
</table>
<h3 id="1222-实际应用示例"><a class="markdownIt-Anchor" href="#1222-实际应用示例"></a> 12.2.2 实际应用示例</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. HTTP请求处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleRequest</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从请求获取context</span></span><br><span class="line">    ctx := r.Context()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置超时</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(ctx, <span class="number">5</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传递给数据库操作</span></span><br><span class="line">    result, err := database.Query(ctx, <span class="string">&quot;SELECT * FROM users&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    json.NewEncoder(w).Encode(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 微服务调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callUserService</span><span class="params">(ctx context.Context, userID <span class="type">string</span>)</span></span> (*User, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 添加链路追踪ID</span></span><br><span class="line">    traceID := ctx.Value(<span class="string">&quot;traceID&quot;</span>).(<span class="type">string</span>)</span><br><span class="line">    ctx = context.WithValue(ctx, <span class="string">&quot;service&quot;</span>, <span class="string">&quot;user-service&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置调用超时</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(ctx, <span class="number">3</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发起HTTP调用</span></span><br><span class="line">    req, _ := http.NewRequest(<span class="string">&quot;GET&quot;</span>, fmt.Sprintf(<span class="string">&quot;http://user-service/users/%s&quot;</span>, userID), <span class="literal">nil</span>)</span><br><span class="line">    req = req.WithContext(ctx)</span><br><span class="line">    </span><br><span class="line">    resp, err := http.DefaultClient.Do(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> user User</span><br><span class="line">    json.NewDecoder(resp.Body).Decode(&amp;user)</span><br><span class="line">    <span class="keyword">return</span> &amp;user, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 后台任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startBackgroundTask</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    ticker := time.NewTicker(time.Second)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="comment">// 收到取消信号，优雅退出</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;后台任务被取消:&quot;</span>, ctx.Err())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            doWork()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 数据库操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserByID</span><span class="params">(ctx context.Context, db *sql.DB, id <span class="type">int</span>)</span></span> (*User, <span class="type">error</span>) &#123;</span><br><span class="line">    query := <span class="string">&quot;SELECT id, name, email FROM users WHERE id = ?&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> user User</span><br><span class="line">    err := db.QueryRowContext(ctx, query, id).Scan(</span><br><span class="line">        &amp;user.ID, &amp;user.Name, &amp;user.Email,</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;user, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1223-context的最佳实践"><a class="markdownIt-Anchor" href="#1223-context的最佳实践"></a> 12.2.3 Context的最佳实践</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Context作为第一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processData</span><span class="params">(ctx context.Context, data []<span class="type">byte</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 正确：context作为第一个参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 不要在struct中存储context</span></span><br><span class="line"><span class="comment">// ❌ 错误</span></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">    ctx context.Context</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确</span></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span></span> Process(ctx context.Context, data []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用context传递请求范围的数据</span></span><br><span class="line"><span class="keyword">type</span> contextKey <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userIDKey contextKey = <span class="string">&quot;userID&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithUserID</span><span class="params">(ctx context.Context, userID <span class="type">string</span>)</span></span> context.Context &#123;</span><br><span class="line">    <span class="keyword">return</span> context.WithValue(ctx, userIDKey, userID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserID</span><span class="params">(ctx context.Context)</span></span> (<span class="type">string</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">    userID, ok := ctx.Value(userIDKey).(<span class="type">string</span>)</span><br><span class="line">    <span class="keyword">return</span> userID, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 正确处理context取消</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longRunningOperation</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 执行耗时操作</span></span><br><span class="line">        done &lt;- doExpensiveWork()</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> err := &lt;-done:</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        <span class="comment">// 操作被取消，清理资源</span></span><br><span class="line">        cleanup()</span><br><span class="line">        <span class="keyword">return</span> ctx.Err()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1224-context使用注意事项"><a class="markdownIt-Anchor" href="#1224-context使用注意事项"></a> 12.2.4 Context使用注意事项</h3>
<ol>
<li><strong>不要传递nil context</strong>：使用<code>context.Background()</code>或<code>context.TODO()</code></li>
<li><strong>context是immutable的</strong>：总是返回新的context</li>
<li><strong>及时调用cancel</strong>：使用defer确保cancel被调用</li>
<li><strong>不要过度使用WithValue</strong>：只传递请求范围的数据</li>
<li><strong>理解context的传播</strong>：context会自动传播到goroutine</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确的context使用模式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleRequest</span><span class="params">(ctx context.Context, req Request)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 创建子context</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(ctx, <span class="number">30</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传递给下游</span></span><br><span class="line">    result, err := processRequest(ctx, req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="13-channel相关"><a class="markdownIt-Anchor" href="#13-channel相关"></a> 13. Channel相关</h1>
<h2 id="131-channel-是纯线程安全锁用在什么地方"><a class="markdownIt-Anchor" href="#131-channel-是纯线程安全锁用在什么地方"></a> 13.1、channel 是纯线程安全？锁用在什么地方？</h2>
<p>Channel 在 Go 中是<strong>并发安全</strong>的，但不是<strong>绝对安全</strong>的。它的实现依赖于以下机制：</p>
<h3 id="1311-内部锁机制"><a class="markdownIt-Anchor" href="#1311-内部锁机制"></a> 13.1.1 内部锁机制</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// channel 底层数据结构</span></span><br><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// 当前队列元素数量</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// 队列容量</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 指向缓冲区数组的指针</span></span><br><span class="line">    elemsize <span class="type">uint16</span>         <span class="comment">// 元素大小</span></span><br><span class="line">    closed   <span class="type">uint32</span>         <span class="comment">// 是否已关闭</span></span><br><span class="line">    elemtype *_type         <span class="comment">// 元素类型</span></span><br><span class="line">    sendx    <span class="type">uint</span>           <span class="comment">// 发送索引</span></span><br><span class="line">    recvx    <span class="type">uint</span>           <span class="comment">// 接收索引</span></span><br><span class="line">    recvq    waitq          <span class="comment">// 接收 goroutine 等待队列</span></span><br><span class="line">    sendq    waitq          <span class="comment">// 发送 goroutine 等待队列</span></span><br><span class="line">    lock     mutex          <span class="comment">// 保护 hchan 的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1312-安全操作与不安全操作"><a class="markdownIt-Anchor" href="#1312-安全操作与不安全操作"></a> 13.1.2 安全操作与不安全操作</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 安全操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safeChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送和接收操作是原子的</span></span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    &lt;-ch</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭操作是安全的</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不安全操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unsafeChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对关闭后的 channel 发送数据会导致 panic</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    ch &lt;- <span class="number">1</span> <span class="comment">// 会 panic</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭 nil channel 会导致 panic</span></span><br><span class="line">    <span class="keyword">var</span> chNil <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    <span class="built_in">close</span>(chNil) <span class="comment">// 会 panic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1313-适用场景"><a class="markdownIt-Anchor" href="#1313-适用场景"></a> 13.1.3 适用场景</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>安全性保证</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一发送者 &amp; 单一接收者</td>
<td>非常安全</td>
</tr>
<tr>
<td>多个发送者 &amp; 单一接收者</td>
<td>需要使用 sync.Once 关闭，或使用 context 取消</td>
</tr>
<tr>
<td>多个发送者 &amp; 多个接收者</td>
<td>需要使用外部同步机制</td>
</tr>
</tbody>
</table>
<h2 id="132-go-channel-的底层实现原理数据结构"><a class="markdownIt-Anchor" href="#132-go-channel-的底层实现原理数据结构"></a> 13.2、go channel 的底层实现原理（数据结构）</h2>
<h3 id="1321-底层实现数据结构"><a class="markdownIt-Anchor" href="#1321-底层实现数据结构"></a> 13.2.1 底层实现数据结构</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待队列</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutine在等待队列中的表示</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    g        *g</span><br><span class="line">    next     *sudog</span><br><span class="line">    prev     *sudog</span><br><span class="line">    elem     unsafe.Pointer</span><br><span class="line">    isSelect <span class="type">bool</span></span><br><span class="line">    c        *hchan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// channel的核心操作流程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 对hchan.lock加锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 检查是否已关闭，已关闭则解锁并panic</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 检查是否有等待的接收者</span></span><br><span class="line">    <span class="keyword">if</span> c.recvq.first != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 直接发送给接收者，解锁</span></span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 检查缓冲区是否已满</span></span><br><span class="line">    <span class="keyword">if</span> c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// 发送到缓冲区，解锁</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 检查是否阻塞</span></span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 阻塞当前goroutine</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    mysg := acquireSudog()</span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    c.sendq.enqueue(mysg)</span><br><span class="line">    goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1322-channel类型性能对比"><a class="markdownIt-Anchor" href="#1322-channel类型性能对比"></a> 13.2.2 channel类型性能对比</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>发送操作(ns/op)</th>
<th>接收操作(ns/op)</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>无缓冲 channel</td>
<td>20-30</td>
<td>20-30</td>
<td>同步通信</td>
</tr>
<tr>
<td>有缓冲 channel(10)</td>
<td>10-15</td>
<td>10-15</td>
<td>异步通信/排队</td>
</tr>
<tr>
<td>无缓冲 channel(多个goroutine)</td>
<td>50-100</td>
<td>50-100</td>
<td>竞争场景</td>
</tr>
</tbody>
</table>
<h2 id="133-nil-关闭的-channel-有数据的-channel再进行读-写-关闭会怎么样各类变种题型"><a class="markdownIt-Anchor" href="#133-nil-关闭的-channel-有数据的-channel再进行读-写-关闭会怎么样各类变种题型"></a> 13.3、nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？（各类变种题型）</h2>
<h3 id="1331-各类操作汇总表"><a class="markdownIt-Anchor" href="#1331-各类操作汇总表"></a> 13.3.1 各类操作汇总表</h3>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>nil channel</th>
<th>已关闭 channel</th>
<th>有数据 channel</th>
<th>无数据 channel</th>
</tr>
</thead>
<tbody>
<tr>
<td>发送数据</td>
<td>永久阻塞</td>
<td>panic</td>
<td>正常发送或阻塞</td>
<td>阻塞或写入</td>
</tr>
<tr>
<td>接收数据</td>
<td>永久阻塞</td>
<td>返回零值 + false</td>
<td>正常接收</td>
<td>阻塞</td>
</tr>
<tr>
<td>关闭操作</td>
<td>panic</td>
<td>panic</td>
<td>正常关闭</td>
<td>正常关闭</td>
</tr>
</tbody>
</table>
<h3 id="1332-详细代码示例"><a class="markdownIt-Anchor" href="#1332-详细代码示例"></a> 13.3.2 详细代码示例</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nil channel 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nilChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送操作：永久阻塞</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch &lt;- <span class="number">1</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;send successful&quot;</span>) <span class="comment">// 永远不会执行</span></span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接收操作：永久阻塞</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">        fmt.Println(<span class="string">&quot;receive successful&quot;</span>) <span class="comment">// 永远不会执行</span></span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭操作：panic</span></span><br><span class="line">    <span class="comment">// close(ch) // 会导致程序崩溃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已关闭 channel 操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closedChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    ch &lt;- <span class="number">2</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取操作：正常读取剩余数据</span></span><br><span class="line">    v1, ok1 := &lt;-ch</span><br><span class="line">    v2, ok2 := &lt;-ch</span><br><span class="line">    v3, ok3 := &lt;-ch</span><br><span class="line">    fmt.Println(v1, ok1) <span class="comment">// 1, true</span></span><br><span class="line">    fmt.Println(v2, ok2) <span class="comment">// 2, true</span></span><br><span class="line">    fmt.Println(v3, ok3) <span class="comment">// 0, false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送操作：panic</span></span><br><span class="line">    <span class="comment">// ch &lt;- 3 // 会panic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1333-常见面试题变种"><a class="markdownIt-Anchor" href="#1333-常见面试题变种"></a> 13.3.3 常见面试题变种</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 面试题1: channel close后读的问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">channelReadAfterClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    </span><br><span class="line">    v, ok := &lt;-ch</span><br><span class="line">    fmt.Printf(<span class="string">&quot;v=%v, ok=%v\n&quot;</span>, v, ok) <span class="comment">// 0, false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 面试题2: 向为nil的channel发送数据会怎么样？</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendToNilChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    <span class="comment">// ch &lt;- 1 // 永久阻塞，会导致程序死锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 面试题3: 向关闭的channel发送数据会怎么样？</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendToClosedChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    <span class="comment">// ch &lt;- 1 // 会panic: send on closed channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="134-向-channel-发送数据和从-channel-读数据的流程是什么样的"><a class="markdownIt-Anchor" href="#134-向-channel-发送数据和从-channel-读数据的流程是什么样的"></a> 13.4、向 channel 发送数据和从 channel 读数据的流程是什么样的？</h2>
<h3 id="1341-发送操作流程"><a class="markdownIt-Anchor" href="#1341-发送操作流程"></a> 13.4.1 发送操作流程</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chansend 函数简化版</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendFlow</span><span class="params">(c *hchan, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 对 channel 加锁</span></span><br><span class="line">    lock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 检查 channel 是否已关闭</span></span><br><span class="line">    <span class="keyword">if</span> c.closed &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;send on closed channel&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 如果有 goroutine 在等待接收，直接发送</span></span><br><span class="line">    <span class="keyword">if</span> !c.recvq.empty() &#123;</span><br><span class="line">        sg := c.recvq.dequeue()</span><br><span class="line">        <span class="comment">// 将数据直接发送给接收者的栈空间</span></span><br><span class="line">        *((*<span class="type">int</span>)(sg.elem)) = value</span><br><span class="line">        <span class="comment">// 唤醒接收者</span></span><br><span class="line">        goready(sg.g, <span class="number">3</span>)</span><br><span class="line">        unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 如果缓冲区未满，写入缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// 计算写入位置</span></span><br><span class="line">        pos := c.sendx</span><br><span class="line">        c.buf[pos] = value</span><br><span class="line">        c.sendx++</span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 发送阻塞，将当前 goroutine 加入发送队列</span></span><br><span class="line">    sg := acquireSudog()</span><br><span class="line">    sg.elem = &amp;value</span><br><span class="line">    sg.c = c</span><br><span class="line">    c.sendq.enqueue(sg)</span><br><span class="line">    <span class="comment">// 阻塞当前 goroutine</span></span><br><span class="line">    gopark()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1342-接收操作流程"><a class="markdownIt-Anchor" href="#1342-接收操作流程"></a> 13.4.2 接收操作流程</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chanrecv 函数简化版</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveFlow</span><span class="params">(c *hchan)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 对 channel 加锁</span></span><br><span class="line">    lock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 如果有 goroutine 在等待发送，直接接收</span></span><br><span class="line">    <span class="keyword">if</span> !c.sendq.empty() &#123;</span><br><span class="line">        sg := c.sendq.dequeue()</span><br><span class="line">        value := *(<span class="type">int</span>*)(sg.elem)</span><br><span class="line">        <span class="comment">// 唤醒发送者</span></span><br><span class="line">        goready(sg.g, <span class="number">3</span>)</span><br><span class="line">        unlock()</span><br><span class="line">        <span class="keyword">return</span> value, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 如果缓冲区有数据，直接读取</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        value := c.buf[c.recvx]</span><br><span class="line">        c.recvx++</span><br><span class="line">        c.qcount--</span><br><span class="line">        unlock()</span><br><span class="line">        <span class="keyword">return</span> value, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 接收阻塞，将当前 goroutine 加入接收队列</span></span><br><span class="line">    sg := acquireSudog()</span><br><span class="line">    <span class="keyword">var</span> value <span class="type">int</span></span><br><span class="line">    sg.elem = &amp;value</span><br><span class="line">    sg.c = c</span><br><span class="line">    c.recvq.enqueue(sg)</span><br><span class="line">    gopark()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="14-map相关"><a class="markdownIt-Anchor" href="#14-map相关"></a> 14. Map相关</h1>
<h2 id="141-map-使用注意的点并发安全"><a class="markdownIt-Anchor" href="#141-map-使用注意的点并发安全"></a> 14.1、map 使用注意的点，并发安全？</h2>
<h3 id="1411-基本特性"><a class="markdownIt-Anchor" href="#1411-基本特性"></a> 14.1.1 基本特性</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建map的不同方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 方法1: 声明nil map</span></span><br><span class="line">    <span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> <span class="comment">// nil，不能直接使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法2: 初始化空map</span></span><br><span class="line">    m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">// 空map，可以使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法3: 带初始化容量</span></span><br><span class="line">    m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">100</span>) <span class="comment">// 预分配100的容量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法4: 字面量初始化</span></span><br><span class="line">    m4 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125; <span class="comment">// 直接初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map使用的基本操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapOperations</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入/更新</span></span><br><span class="line">    m[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">    m[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取</span></span><br><span class="line">    v1 := m[<span class="string">&quot;a&quot;</span>]</span><br><span class="line">    fmt.Println(v1) <span class="comment">// 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断键是否存在</span></span><br><span class="line">    v2, ok := m[<span class="string">&quot;b&quot;</span>]</span><br><span class="line">    fmt.Printf(<span class="string">&quot;v: %v, ok: %v\n&quot;</span>, v2, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1412-并发安全问题"><a class="markdownIt-Anchor" href="#1412-并发安全问题"></a> 14.1.2 并发安全问题</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误示例：并发读写map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concurrentMapAccess</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动多个goroutine进行读写操作</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>, value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 写入</span></span><br><span class="line">            m[key] = value</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 读取</span></span><br><span class="line">            fmt.Println(m[<span class="string">&quot;a&quot;</span>])</span><br><span class="line">        &#125;(fmt.Sprintf(<span class="string">&quot;key%d&quot;</span>, i), i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1413-解决并发安全的方法"><a class="markdownIt-Anchor" href="#1413-解决并发安全的方法"></a> 14.1.3 解决并发安全的方法</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 方法1: 使用sync.RWMutex（推荐）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safeMap1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> SafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">        sync.RWMutex</span><br><span class="line">        data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sm := SafeMap&#123;</span><br><span class="line">        data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>, value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 写操作，使用互斥锁</span></span><br><span class="line">            sm.Lock()</span><br><span class="line">            sm.data[key] = value</span><br><span class="line">            sm.Unlock()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 读操作，使用读写锁</span></span><br><span class="line">            sm.RLock()</span><br><span class="line">            fmt.Println(sm.data[<span class="string">&quot;a&quot;</span>])</span><br><span class="line">            sm.RUnlock()</span><br><span class="line">        &#125;(fmt.Sprintf(<span class="string">&quot;key%d&quot;</span>, i), i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 方法2: 使用sync.Map（Go 1.9+）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safeMap2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sm sync.Map</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>, value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 写入</span></span><br><span class="line">            sm.Store(key, value)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 读取</span></span><br><span class="line">            v, ok := sm.Load(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> ok &#123;</span><br><span class="line">                fmt.Println(v)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(fmt.Sprintf(<span class="string">&quot;key%d&quot;</span>, i), i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 方法3: 使用channel序列化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safeMap3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> Operation <span class="keyword">struct</span> &#123;</span><br><span class="line">        key     <span class="type">string</span></span><br><span class="line">        value   <span class="type">int</span></span><br><span class="line">        op      <span class="type">string</span> <span class="comment">// &quot;set&quot; or &quot;get&quot;</span></span><br><span class="line">        result  <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 操作通道</span></span><br><span class="line">    opsCh := <span class="built_in">make</span>(<span class="keyword">chan</span> Operation, <span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部 goroutine 处理操作</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">        <span class="keyword">for</span> op := <span class="keyword">range</span> opsCh &#123;</span><br><span class="line">            <span class="keyword">switch</span> op.op &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;set&quot;</span>:</span><br><span class="line">                m[op.key] = op.value</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;get&quot;</span>:</span><br><span class="line">                op.result &lt;- m[op.key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>, value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            opsCh &lt;- Operation&#123;key, value, <span class="string">&quot;set&quot;</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">        &#125;(fmt.Sprintf(<span class="string">&quot;key%d&quot;</span>, i), i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="142-map-循环是有序的还是无序的"><a class="markdownIt-Anchor" href="#142-map-循环是有序的还是无序的"></a> 14.2、map 循环是有序的还是无序的？</h2>
<h3 id="1421-无序性演示"><a class="markdownIt-Anchor" href="#1421-无序性演示"></a> 14.2.1 无序性演示</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 演示map遍历的无序性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapUnordered</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>, <span class="string">&quot;c&quot;</span>:<span class="number">3</span>, <span class="string">&quot;d&quot;</span>:<span class="number">4</span>, <span class="string">&quot;e&quot;</span>:<span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;第一次遍历:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;k:%s, v:%d\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;\n第二次遍历:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;k:%s, v:%d\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出通常会不同，因为map的遍历顺序是随机的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1422-确保有序遍历的方法"><a class="markdownIt-Anchor" href="#1422-确保有序遍历的方法"></a> 14.2.2 确保有序遍历的方法</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取有序键的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapSortedKeys</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// 获取所有键</span></span><br><span class="line">    keys := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(m))</span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">        keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    sort.Strings(keys)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> keys</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有序遍历map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedMapIteration</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>, <span class="string">&quot;c&quot;</span>:<span class="number">3</span>, <span class="string">&quot;d&quot;</span>:<span class="number">4</span>, <span class="string">&quot;e&quot;</span>:<span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取排序后的键</span></span><br><span class="line">    sortedKeys := mapSortedKeys(m)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按顺序遍历</span></span><br><span class="line">    <span class="keyword">for</span> _, k := <span class="keyword">range</span> sortedKeys &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;k:%s, v:%d\n&quot;</span>, k, m[k])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="143-map-中删除一个-key它的内存会释放么"><a class="markdownIt-Anchor" href="#143-map-中删除一个-key它的内存会释放么"></a> 14.3、map 中删除一个 key，它的内存会释放么？</h2>
<h3 id="1431-内存释放机制"><a class="markdownIt-Anchor" href="#1431-内存释放机制"></a> 14.3.1 内存释放机制</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 演示map的内存释放</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapMemory</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个大map</span></span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*<span class="keyword">struct</span>&#123;&#125;, <span class="number">1000000</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">        m[i] = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;创建map后内存使用:&quot;</span>)</span><br><span class="line">    printMemUsage() <span class="comment">// 打印当前内存使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除所有元素</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">        <span class="built_in">delete</span>(m, i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;删除所有元素后内存使用:&quot;</span>)</span><br><span class="line">    printMemUsage() <span class="comment">// 内存并没有立即释放</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手动触发GC</span></span><br><span class="line">    runtime.GC()</span><br><span class="line">    fmt.Println(<span class="string">&quot;手动GC后内存使用:&quot;</span>)</span><br><span class="line">    printMemUsage() <span class="comment">// 内存释放了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1432-内存释放策略"><a class="markdownIt-Anchor" href="#1432-内存释放策略"></a> 14.3.2 内存释放策略</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map的负载因子</span></span><br><span class="line"><span class="comment">// 当负载因子 &lt; 6.5 时，删除不会导致缩容</span></span><br><span class="line"><span class="comment">// 只有当负载因子 &lt; 2.5 且有大量删除时，才会缩容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapResizing</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 负载因子 = 元素数量 / 桶数量</span></span><br><span class="line">    <span class="comment">// 扩容阈值: 6.5，缩容阈值: 2.5</span></span><br><span class="line">    </span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">100</span>) <span class="comment">// 初始4个桶</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入到负载因子接近6.5</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">26</span>; i++ &#123;</span><br><span class="line">        m[i] = i <span class="comment">// 26个元素，4个桶，负载因子6.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除元素到负载因子 &lt; 2.5</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">18</span>; i++ &#123;</span><br><span class="line">        <span class="built_in">delete</span>(m, i) <span class="comment">// 8个元素，4个桶，负载因子2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此时执行GC会触发缩容到2个桶</span></span><br><span class="line">    runtime.GC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="144-怎么处理对-map-进行并发访问有没有其他方案区别是什么"><a class="markdownIt-Anchor" href="#144-怎么处理对-map-进行并发访问有没有其他方案区别是什么"></a> 14.4、怎么处理对 map 进行并发访问？有没有其他方案？区别是什么？</h2>
<h3 id="1441-各种方案对比"><a class="markdownIt-Anchor" href="#1441-各种方案对比"></a> 14.4.1 各种方案对比</h3>
<table>
<thead>
<tr>
<th>方案</th>
<th>实现方式</th>
<th>读性能</th>
<th>写性能</th>
<th>内存开销</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>sync.Mutex</td>
<td>互斥锁</td>
<td>一般</td>
<td>一般</td>
<td>低</td>
<td>读写频率均匀</td>
</tr>
<tr>
<td>sync.RWMutex</td>
<td>读写锁</td>
<td>高</td>
<td>一般</td>
<td>低</td>
<td>读多写少</td>
</tr>
<tr>
<td>sync.Map</td>
<td>原子操作+分片</td>
<td>高</td>
<td>高</td>
<td>中</td>
<td>高频读写</td>
</tr>
<tr>
<td>channel 序列化</td>
<td>发送到单goroutine处理</td>
<td>一般</td>
<td>一般</td>
<td>中</td>
<td>需要复杂操作</td>
</tr>
</tbody>
</table>
<h3 id="1442-方案选择策略"><a class="markdownIt-Anchor" href="#1442-方案选择策略"></a> 14.4.2 方案选择策略</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据场景选择合适的并发安全方案</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseConcurrentMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 场景1: 读多写少 (如配置)</span></span><br><span class="line">    configMap := <span class="keyword">struct</span> &#123;</span><br><span class="line">        sync.RWMutex</span><br><span class="line">        data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">    &#125;&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景2: 高频读写 (如缓存)</span></span><br><span class="line">    cacheMap := sync.Map&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景3: 需要复杂计算的操作</span></span><br><span class="line">    <span class="keyword">type</span> Operation <span class="keyword">struct</span> &#123;</span><br><span class="line">        key    <span class="type">string</span></span><br><span class="line">        value  <span class="type">string</span></span><br><span class="line">        op     <span class="type">string</span></span><br><span class="line">        result <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    opsCh := <span class="built_in">make</span>(<span class="keyword">chan</span> Operation, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">        <span class="keyword">for</span> op := <span class="keyword">range</span> opsCh &#123;</span><br><span class="line">            <span class="keyword">switch</span> op.op &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;get&quot;</span>:</span><br><span class="line">                op.result &lt;- m[op.key]</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;set&quot;</span>:</span><br><span class="line">                m[op.key] = op.value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="145-nil-map-和空-map-有何不同"><a class="markdownIt-Anchor" href="#145-nil-map-和空-map-有何不同"></a> 14.5、nil map 和空 map 有何不同？</h2>
<h3 id="1451-基本区别"><a class="markdownIt-Anchor" href="#1451-基本区别"></a> 14.5.1 基本区别</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapNilVsEmpty</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> <span class="comment">// nil map</span></span><br><span class="line">    m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">// 空 map</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较nil</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;m1 == nil:&quot;</span>, m1 == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;m2 == nil:&quot;</span>, m2 == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较长度</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;len(m1):&quot;</span>, <span class="built_in">len</span>(m1)) <span class="comment">// 0</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;len(m2):&quot;</span>, <span class="built_in">len</span>(m2)) <span class="comment">// 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除操作</span></span><br><span class="line">    <span class="built_in">delete</span>(m1, <span class="string">&quot;key&quot;</span>) <span class="comment">// 允许</span></span><br><span class="line">    <span class="built_in">delete</span>(m2, <span class="string">&quot;key&quot;</span>) <span class="comment">// 允许</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    <span class="comment">// m1[&quot;key&quot;] = 1 // 会导致 panic</span></span><br><span class="line">    </span><br><span class="line">    m2[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span> <span class="comment">// 正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1452-安全操作-nil-map-的方法"><a class="markdownIt-Anchor" href="#1452-安全操作-nil-map-的方法"></a> 14.5.2 安全操作 nil map 的方法</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safeNilMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正确做法：检查nil并初始化</span></span><br><span class="line">    <span class="keyword">if</span> m == <span class="literal">nil</span> &#123;</span><br><span class="line">        m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或者使用指针避免nil检查</span></span><br><span class="line">    <span class="keyword">type</span> MapPtr *<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> mp MapPtr = <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">if</span> *mp == <span class="literal">nil</span> &#123;</span><br><span class="line">        *mp = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    (*mp)[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="146-map-的数据结构是什么是怎么实现扩容的"><a class="markdownIt-Anchor" href="#146-map-的数据结构是什么是怎么实现扩容的"></a> 14.6、map 的数据结构是什么？是怎么实现扩容的？</h2>
<h3 id="1461-底层实现结构"><a class="markdownIt-Anchor" href="#1461-底层实现结构"></a> 14.6.1 底层实现结构</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map的bucket结构</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [<span class="number">8</span>]<span class="type">uint8</span> <span class="comment">// 哈希值的高8位用于快速查找</span></span><br><span class="line">    <span class="comment">// 实际数据存储区，包含8个key-value对，key顺序存储</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map的核心结构</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="type">int</span> <span class="comment">// 元素数量</span></span><br><span class="line">    flags     <span class="type">uint8</span> <span class="comment">// 状态标志</span></span><br><span class="line">    B         <span class="type">uint8</span> <span class="comment">// log2(桶数量)</span></span><br><span class="line">    noverflow <span class="type">uint16</span> <span class="comment">// 溢出桶数量</span></span><br><span class="line">    hash0     <span class="type">uint32</span> <span class="comment">// 哈希种子</span></span><br><span class="line">    </span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// 指向桶数组的指针</span></span><br><span class="line">    oldbuckets unsafe.Pointer <span class="comment">// 扩容时的旧桶</span></span><br><span class="line">    nevacuate  <span class="type">uintptr</span> <span class="comment">// 扩容进度</span></span><br><span class="line">    </span><br><span class="line">    extra *mapextra <span class="comment">// 溢出桶信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1462-扩容机制"><a class="markdownIt-Anchor" href="#1462-扩容机制"></a> 14.6.2 扩容机制</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容条件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldGrow</span><span class="params">(m *hmap)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    loadFactor := <span class="type">float64</span>(m.count) / (<span class="type">float64</span>(<span class="number">1</span>) &lt;&lt; m.B)</span><br><span class="line">    <span class="comment">// 负载因子超过6.5或有大量溢出桶</span></span><br><span class="line">    <span class="keyword">return</span> loadFactor &gt; <span class="number">6.5</span> || (m.noverflow &gt; <span class="type">uint16</span>(m.B) &amp;&amp; m.B &gt; <span class="number">15</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果oldbuckets存在，表明正在扩容</span></span><br><span class="line">    <span class="keyword">if</span> h.oldbuckets != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 迁移一个桶</span></span><br><span class="line">        evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line">        <span class="comment">// 清空oldbuckets</span></span><br><span class="line">        <span class="keyword">if</span> h.nevacuate == bucket &#123;</span><br><span class="line">            h.nevacuate++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体迁移逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 查找旧桶的所有元素</span></span><br><span class="line">    <span class="comment">// 2. 计算新的位置</span></span><br><span class="line">    <span class="comment">// 3. 迁移到新桶</span></span><br><span class="line">    <span class="comment">// 4. 处理溢出桶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="147-map-取一个-key然后修改这个值原-map-数据的值会不会变化"><a class="markdownIt-Anchor" href="#147-map-取一个-key然后修改这个值原-map-数据的值会不会变化"></a> 14.7、map 取一个 key，然后修改这个值，原 map 数据的值会不会变化</h2>
<h3 id="1471-基本规则"><a class="markdownIt-Anchor" href="#1471-基本规则"></a> 14.7.1 基本规则</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapValueMutation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 情况1: 基本类型</span></span><br><span class="line">    m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">    v := m1[<span class="string">&quot;a&quot;</span>]</span><br><span class="line">    v = <span class="number">100</span></span><br><span class="line">    fmt.Println(m1[<span class="string">&quot;a&quot;</span>]) <span class="comment">// 1，没有变化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况2: 指针类型</span></span><br><span class="line">    m2 := <span class="keyword">map</span>[<span class="type">string</span>]*<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="built_in">new</span>(<span class="type">int</span>)&#125;</span><br><span class="line">    *m2[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">    v2 := m2[<span class="string">&quot;a&quot;</span>]</span><br><span class="line">    *v2 = <span class="number">100</span></span><br><span class="line">    fmt.Println(*m2[<span class="string">&quot;a&quot;</span>]) <span class="comment">// 100，变化了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况3: 结构体类型（不可直接修改）</span></span><br><span class="line">    <span class="keyword">type</span> Point <span class="keyword">struct</span> &#123; X, Y <span class="type">int</span> &#125;</span><br><span class="line">    m3 := <span class="keyword">map</span>[<span class="type">string</span>]Point&#123;<span class="string">&quot;a&quot;</span>: &#123;X: <span class="number">1</span>, Y: <span class="number">2</span>&#125;&#125;</span><br><span class="line">    <span class="comment">// p := m3[&quot;a&quot;]</span></span><br><span class="line">    <span class="comment">// p.X = 100 // 编译错误！</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况4: 结构体指针</span></span><br><span class="line">    m4 := <span class="keyword">map</span>[<span class="type">string</span>]*Point&#123;<span class="string">&quot;a&quot;</span>: &#123;X: <span class="number">1</span>, Y: <span class="number">2</span>&#125;&#125;</span><br><span class="line">    m4[<span class="string">&quot;a&quot;</span>].X = <span class="number">100</span> <span class="comment">// 直接修改，会变化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="15-gmp相关"><a class="markdownIt-Anchor" href="#15-gmp相关"></a> 15. GMP相关</h1>
<h2 id="151-什么是-gmp必问调度流程是什么样的对流程熟悉要求更高问的较多"><a class="markdownIt-Anchor" href="#151-什么是-gmp必问调度流程是什么样的对流程熟悉要求更高问的较多"></a> 15.1、什么是 GMP？（必问）调度流程是什么样的？（对流程熟悉，要求更高，问的较多）</h2>
<h3 id="1511-基本概念"><a class="markdownIt-Anchor" href="#1511-基本概念"></a> 15.1.1 基本概念</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GMP模型的三个核心组件</span></span><br><span class="line"><span class="keyword">type</span> G <span class="keyword">struct</span> &#123;</span><br><span class="line">    goid         <span class="type">int64</span>   <span class="comment">// goroutine ID</span></span><br><span class="line">    stack        stack   <span class="comment">// 堆栈信息</span></span><br><span class="line">    sched        gobuf   <span class="comment">// 调度信息</span></span><br><span class="line">    gopc         <span class="type">uintptr</span> <span class="comment">// 创建位置</span></span><br><span class="line">    startpc      <span class="type">uintptr</span> <span class="comment">// 函数入口</span></span><br><span class="line">    param        unsafe.Pointer <span class="comment">// 传递参数</span></span><br><span class="line">    atomicstatus <span class="type">uint32</span>  <span class="comment">// 状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> M <span class="keyword">struct</span> &#123;</span><br><span class="line">    id            <span class="type">int32</span>   <span class="comment">// 线程ID</span></span><br><span class="line">    g0            *g      <span class="comment">// 调度goroutine</span></span><br><span class="line">    gsignal       *g      <span class="comment">// 信号处理goroutine</span></span><br><span class="line">    tls           [<span class="number">6</span>]<span class="type">uintptr</span> <span class="comment">// 线程本地存储</span></span><br><span class="line">    mstartfn      <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="comment">// 启动函数</span></span><br><span class="line">    curg          *g      <span class="comment">// 当前正在执行的goroutine</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P <span class="keyword">struct</span> &#123;</span><br><span class="line">    id            <span class="type">int32</span>   <span class="comment">// 逻辑 processor ID</span></span><br><span class="line">    status        <span class="type">uint32</span>  <span class="comment">// 状态</span></span><br><span class="line">    runqhead      <span class="type">uint32</span>  <span class="comment">// 本地队列头</span></span><br><span class="line">    runqtail      <span class="type">uint32</span>  <span class="comment">// 本地队列尾</span></span><br><span class="line">    runq          [<span class="number">256</span>]guintptr <span class="comment">// 本地goroutine队列</span></span><br><span class="line">    syscalltick   <span class="type">uint32</span>  <span class="comment">// 系统调用计数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1512-调度流程"><a class="markdownIt-Anchor" href="#1512-调度流程"></a> 15.1.2 调度流程</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度器启动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime</span>·<span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化调度器状态</span></span><br><span class="line">    <span class="comment">// 创建P并启动M</span></span><br><span class="line">    <span class="comment">// 设置调度器参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutine调度流程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 检查本地队列</span></span><br><span class="line">    gp, inheritTime := findRunnable()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 执行goroutine</span></span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(gp *g, inheritTime <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line">    _g_.m.curg = gp</span><br><span class="line">    gp.m = _g_.m</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行前处理</span></span><br><span class="line">    gogo(&amp;gp.sched)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行后处理</span></span><br><span class="line">    gp.m = <span class="literal">nil</span></span><br><span class="line">    _g_.m.curg = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1513-调度流程详解"><a class="markdownIt-Anchor" href="#1513-调度流程详解"></a> 15.1.3 调度流程详解</h3>
<table>
<thead>
<tr>
<th>阶段</th>
<th>主要操作</th>
<th>时间点</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化</td>
<td>初始化P队列、创建系统线程</td>
<td>程序启动</td>
</tr>
<tr>
<td>调度准备</td>
<td>查找可运行goroutine、抢占处理</td>
<td>每次调度时</td>
</tr>
<tr>
<td>执行</td>
<td>设置上下文、执行函数</td>
<td>goroutine切换时</td>
</tr>
<tr>
<td>恢复</td>
<td>保存状态、继续调度</td>
<td>goroutine阻塞或结束</td>
</tr>
</tbody>
</table>
<h2 id="152-进程-线程-协程有什么区别"><a class="markdownIt-Anchor" href="#152-进程-线程-协程有什么区别"></a> 15.2、进程、线程、协程有什么区别？</h2>
<h3 id="1521-基本概念对比"><a class="markdownIt-Anchor" href="#1521-基本概念对比"></a> 15.2.1 基本概念对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>进程</th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody>
<tr>
<td>拥有资源</td>
<td>有独立地址空间</td>
<td>共享进程资源</td>
<td>共享进程资源</td>
</tr>
<tr>
<td>调度</td>
<td>系统调度</td>
<td>系统调度</td>
<td>用户调度</td>
</tr>
<tr>
<td>切换开销</td>
<td>大（毫秒级）</td>
<td>中（微秒级）</td>
<td>小（纳秒级）</td>
</tr>
<tr>
<td>并发数量</td>
<td>有限（百级）</td>
<td>有限（千级）</td>
<td>大量（百万级）</td>
</tr>
<tr>
<td>通信方式</td>
<td>IPC（管道、共享内存等）</td>
<td>共享内存</td>
<td>通道或消息传递</td>
</tr>
</tbody>
</table>
<h3 id="1522-go协程的优势"><a class="markdownIt-Anchor" href="#1522-go协程的优势"></a> 15.2.2 Go协程的优势</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 演示goroutine的高效性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutineEfficiency</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 启动100万个goroutine</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1000000</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            ch &lt;- x * x</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        <span class="built_in">close</span>(ch)</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        sum += x</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;1到999999平方和: %d\n&quot;</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="153-抢占式调度是如何抢占的"><a class="markdownIt-Anchor" href="#153-抢占式调度是如何抢占的"></a> 15.3、抢占式调度是如何抢占的？</h2>
<h3 id="1531-抢占触发条件"><a class="markdownIt-Anchor" href="#1531-抢占触发条件"></a> 15.3.1 抢占触发条件</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈增长检查触发抢占</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">morestack</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检测到栈增长时，触发抢占</span></span><br><span class="line">    <span class="comment">// 将goroutine状态标记为需要抢占</span></span><br><span class="line">    <span class="comment">// 当goroutine下一次进入调度点时会被抢占</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统调用返回触发调度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entersyscallblock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 系统调用阻塞后，释放P</span></span><br><span class="line">    <span class="comment">// 调度器可以将P分配给其他M</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主动调用触发调度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gosched</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 主动放弃CPU，重新调度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1532-抢占实现机制"><a class="markdownIt-Anchor" href="#1532-抢占实现机制"></a> 15.3.2 抢占实现机制</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器触发抢占</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 系统监控goroutine，定期检查长时间运行的goroutine</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        now := nanotime()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否有长时间运行的goroutine（&gt; 10ms）</span></span><br><span class="line">        <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">            <span class="keyword">if</span> gp := p.curg; gp != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> now-gp.schedwhen &gt; <span class="number">10</span>*<span class="number">1e9</span> &#123;</span><br><span class="line">                    <span class="comment">// 标记为需要抢占</span></span><br><span class="line">                    casgstatus(gp, _Grunning, _Gpreempted)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        osyield()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行前检查是否需要抢占</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(gp *g, inheritTime <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line">    _g_.m.curg = gp</span><br><span class="line">    gp.m = _g_.m</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行前检查是否需要抢占</span></span><br><span class="line">    <span class="keyword">if</span> gp.atomicstatus == _Gpreempted &#123;</span><br><span class="line">        <span class="comment">// 进入调度流程</span></span><br><span class="line">        goexit1()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="154-m-和-p-的数量问题"><a class="markdownIt-Anchor" href="#154-m-和-p-的数量问题"></a> 15.4、M 和 P 的数量问题？</h2>
<h3 id="1541-默认值与配置"><a class="markdownIt-Anchor" href="#1541-默认值与配置"></a> 15.4.1 默认值与配置</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printConfig</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// GOMAXPROCS是P的数量，默认是CPU核数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;GOMAXPROCS:&quot;</span>, runtime.GOMAXPROCS(<span class="number">0</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正在运行的P数量</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;NumCPU:&quot;</span>, runtime.NumCPU())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正在运行的M数量</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;NumGoroutine:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置GOMAXPROCS</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setGOMAXPROCS</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置为CPU核数的2倍</span></span><br><span class="line">    runtime.GOMAXPROCS(runtime.NumCPU() * <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;New GOMAXPROCS:&quot;</span>, runtime.GOMAXPROCS(<span class="number">0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1542-最佳实践"><a class="markdownIt-Anchor" href="#1542-最佳实践"></a> 15.4.2 最佳实践</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据任务类型选择合适的GOMAXPROCS值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseGOMAXPROCS</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计算密集型任务：设置为CPU核数</span></span><br><span class="line">    runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// IO密集型任务：可以设置更大的值</span></span><br><span class="line">    <span class="comment">// runtime.GOMAXPROCS(runtime.NumCPU() * 2)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 大量并发请求场景：设置更大的值</span></span><br><span class="line">    <span class="comment">// runtime.GOMAXPROCS(runtime.NumCPU() * 4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="155-协程怎么退出"><a class="markdownIt-Anchor" href="#155-协程怎么退出"></a> 15.5、协程怎么退出？</h2>
<h3 id="1551-协程退出的方式"><a class="markdownIt-Anchor" href="#1551-协程退出的方式"></a> 15.5.1 协程退出的方式</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1: 正常执行完毕</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">normalExit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;goroutine 正在执行&quot;</span>)</span><br><span class="line">        <span class="comment">// 函数执行完毕后自动退出</span></span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2: 返回值方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnExit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;goroutine 正在执行&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span> <span class="comment">// 返回后退出</span></span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3: 使用runtime.Goexit()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexitExit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer 会执行&quot;</span>)</span><br><span class="line">        runtime.Goexit() <span class="comment">// 直接退出</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;不会执行&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式4: 主goroutine结束</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mainExit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        fmt.Println(<span class="string">&quot;不会执行&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;main goroutine 结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1552-处理协程的优雅退出"><a class="markdownIt-Anchor" href="#1552-处理协程的优雅退出"></a> 15.5.2 处理协程的优雅退出</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用context优雅退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gracefulExitWithContext</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">                fmt.Println(<span class="string">&quot;收到取消信号，退出&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Println(<span class="string">&quot;正在工作...&quot;</span>)</span><br><span class="line">                time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(ctx)</span><br><span class="line">    </span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    cancel()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用channel优雅退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gracefulExitWithChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    quitCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">                fmt.Println(<span class="string">&quot;收到退出信号&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Println(<span class="string">&quot;正在工作...&quot;</span>)</span><br><span class="line">                time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(quitCh)</span><br><span class="line">    </span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    quitCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="156-map-如何顺序读取"><a class="markdownIt-Anchor" href="#156-map-如何顺序读取"></a> 15.6、map 如何顺序读取？</h2>
<h3 id="1561-标准库方案"><a class="markdownIt-Anchor" href="#1561-标准库方案"></a> 15.6.1 标准库方案</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用顺序读取map的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">iterateMapOrderly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;c&quot;</span>:<span class="number">1</span>, <span class="string">&quot;a&quot;</span>:<span class="number">2</span>, <span class="string">&quot;b&quot;</span>:<span class="number">3</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取所有键并排序</span></span><br><span class="line">    keys := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(m))</span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">        keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    sort.Strings(keys)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按顺序访问</span></span><br><span class="line">    <span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;k: %s, v: %d\n&quot;</span>, k, m[k])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">iterateMapByValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;c&quot;</span>:<span class="number">1</span>, <span class="string">&quot;a&quot;</span>:<span class="number">2</span>, <span class="string">&quot;b&quot;</span>:<span class="number">3</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> kv <span class="keyword">struct</span> &#123;</span><br><span class="line">        Key <span class="type">string</span></span><br><span class="line">        Value <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> pairs []kv</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        pairs = <span class="built_in">append</span>(pairs, kv&#123;k, v&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort.Slice(pairs, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pairs[i].Value &lt; pairs[j].Value <span class="comment">// 按值升序</span></span><br><span class="line">        <span class="comment">// return pairs[i].Value &gt; pairs[j].Value // 按值降序</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> pairs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;k: %s, v: %d\n&quot;</span>, p.Key, p.Value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1562-使用结构体封装的方式"><a class="markdownIt-Anchor" href="#1562-使用结构体封装的方式"></a> 15.6.2 使用结构体封装的方式</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用结构体封装的有序map</span></span><br><span class="line"><span class="keyword">type</span> OrderedMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    keys []<span class="type">string</span></span><br><span class="line">    data <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderedMap</span><span class="params">()</span></span> *OrderedMap &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;OrderedMap&#123;</span><br><span class="line">        data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(om *OrderedMap)</span></span> Set(key <span class="type">string</span>, value <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    om.Lock()</span><br><span class="line">    <span class="keyword">defer</span> om.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> _, exists := om.data[key]; !exists &#123;</span><br><span class="line">        om.keys = <span class="built_in">append</span>(om.keys, key)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    om.data[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(om *OrderedMap)</span></span> Get(key <span class="type">string</span>) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    om.RLock()</span><br><span class="line">    <span class="keyword">defer</span> om.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> om.data[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(om *OrderedMap)</span></span> Delete(key <span class="type">string</span>) &#123;</span><br><span class="line">    om.Lock()</span><br><span class="line">    <span class="keyword">defer</span> om.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> _, exists := om.data[key]; exists &#123;</span><br><span class="line">        <span class="built_in">delete</span>(om.data, key)</span><br><span class="line">        <span class="keyword">for</span> i, k := <span class="keyword">range</span> om.keys &#123;</span><br><span class="line">            <span class="keyword">if</span> k == key &#123;</span><br><span class="line">                om.keys = <span class="built_in">append</span>(om.keys[:i], om.keys[i+<span class="number">1</span>:]...)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(om *OrderedMap)</span></span> Iterate() <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="type">string</span>, <span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">    om.RLock()</span><br><span class="line">    <span class="keyword">defer</span> om.RUnlock()</span><br><span class="line">    </span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    keys := <span class="built_in">append</span>([]<span class="type">string</span>(<span class="literal">nil</span>), om.keys...)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="type">string</span>, <span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(keys) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        k := keys[i]</span><br><span class="line">        v := om.data[k]</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> k, v, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useOrderedMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">    om := NewOrderedMap()</span><br><span class="line">    om.Set(<span class="string">&quot;c&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    om.Set(<span class="string">&quot;a&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    om.Set(<span class="string">&quot;b&quot;</span>, <span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    iter := om.Iterate()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        k, v, ok := iter()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;k: %s, v: %v\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="16-锁相关"><a class="markdownIt-Anchor" href="#16-锁相关"></a> 16. 锁相关</h1>
<h2 id="161-除了-mutex-以外还有那些方式安全读写共享变量"><a class="markdownIt-Anchor" href="#161-除了-mutex-以外还有那些方式安全读写共享变量"></a> 16.1、除了 mutex 以外还有那些方式安全读写共享变量？</h2>
<h3 id="1611-各种同步原语对比"><a class="markdownIt-Anchor" href="#1611-各种同步原语对比"></a> 16.1.1 各种同步原语对比</h3>
<table>
<thead>
<tr>
<th>方式</th>
<th>实现原理</th>
<th>适用场景</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>sync.Mutex</td>
<td>互斥锁</td>
<td>任意场景</td>
<td>简单、通用</td>
<td>性能一般、不能升级</td>
</tr>
<tr>
<td>sync.RWMutex</td>
<td>读写锁</td>
<td>读多写少</td>
<td>读性能高</td>
<td>写性能一般</td>
</tr>
<tr>
<td>sync.Once</td>
<td>单例模式</td>
<td>初始化</td>
<td>保证只执行一次</td>
<td>功能单一</td>
</tr>
<tr>
<td>sync.WaitGroup</td>
<td>等待组</td>
<td>任务同步</td>
<td>简单易用</td>
<td>不能取消</td>
</tr>
<tr>
<td>sync.Cond</td>
<td>条件变量</td>
<td>条件等待</td>
<td>灵活控制</td>
<td>实现复杂</td>
</tr>
<tr>
<td>atomic 操作</td>
<td>原子指令</td>
<td>简单操作</td>
<td>高性能、无锁</td>
<td>操作单一</td>
</tr>
</tbody>
</table>
<h3 id="1612-atomic-操作示例"><a class="markdownIt-Anchor" href="#1612-atomic-操作示例"></a> 16.1.2 atomic 操作示例</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用atomic操作实现计数器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomicCounter</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> counter <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动100个goroutine进行加法操作</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">                atomic.AddInt64(&amp;counter, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;最终计数:&quot;</span>, atomic.LoadInt64(&amp;counter))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用atomic操作实现并发安全的状态管理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomicState</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> state <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 原子写入状态</span></span><br><span class="line">        atomic.StoreInt32(&amp;state, <span class="number">1</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 原子读取状态</span></span><br><span class="line">        currentState := atomic.LoadInt32(&amp;state)</span><br><span class="line">        fmt.Println(<span class="string">&quot;当前状态:&quot;</span>, currentState)</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="162-go-如何实现原子操作"><a class="markdownIt-Anchor" href="#162-go-如何实现原子操作"></a> 16.2、Go 如何实现原子操作？</h2>
<h3 id="1621-底层原理"><a class="markdownIt-Anchor" href="#1621-底层原理"></a> 16.2.1 底层原理</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子操作的核心 - 内存屏障</span></span><br><span class="line"><span class="keyword">type</span> memoryBarrier <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mb *memoryBarrier)</span></span> Load() &#123;</span><br><span class="line">    <span class="comment">// 强制刷新CPU缓存</span></span><br><span class="line">    <span class="comment">// 确保其他CPU看到最新的内存状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mb *memoryBarrier)</span></span> Store() &#123;</span><br><span class="line">    <span class="comment">// 强制刷新写缓冲区</span></span><br><span class="line">    <span class="comment">// 确保内存操作的顺序性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作实现的基本原理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomicAdd</span><span class="params">(addr *<span class="type">int64</span>, delta <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 读取变量的当前值</span></span><br><span class="line">        old := *addr</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 计算新值</span></span><br><span class="line">        newVal := old + delta</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. CAS操作：如果变量的值还是old，就更新为newVal</span></span><br><span class="line">        <span class="keyword">if</span> cas(addr, old, newVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> newVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟CPU的比较和交换指令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cas</span><span class="params">(addr *<span class="type">int64</span>, old, newVal <span class="type">int64</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.CompareAndSwapInt64(addr, old, newVal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1622-原子操作的类型"><a class="markdownIt-Anchor" href="#1622-原子操作的类型"></a> 16.2.2 原子操作的类型</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子操作的类型支持</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomicTypes</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 基本类型的原子操作</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        i32  <span class="type">int32</span></span><br><span class="line">        i64  <span class="type">int64</span></span><br><span class="line">        u32  <span class="type">uint32</span></span><br><span class="line">        u64  <span class="type">uint64</span></span><br><span class="line">        ptr  unsafe.Pointer</span><br><span class="line">        flag <span class="type">uint32</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加法操作</span></span><br><span class="line">    atomic.AddInt32(&amp;i32, <span class="number">1</span>)</span><br><span class="line">    atomic.AddInt64(&amp;i64, <span class="number">1</span>)</span><br><span class="line">    atomic.AddUint32(&amp;u32, <span class="number">1</span>)</span><br><span class="line">    atomic.AddUint64(&amp;u64, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储操作</span></span><br><span class="line">    atomic.StoreInt32(&amp;i32, <span class="number">100</span>)</span><br><span class="line">    atomic.StorePointer(&amp;ptr, unsafe.Pointer(&amp;i32))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取操作</span></span><br><span class="line">    v32 := atomic.LoadInt32(&amp;i32)</span><br><span class="line">    v64 := atomic.LoadInt64(&amp;i64)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较和交换</span></span><br><span class="line">    atomic.CompareAndSwapInt32(&amp;i32, <span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换操作</span></span><br><span class="line">    oldV := atomic.SwapInt32(&amp;i32, <span class="number">300</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 位操作</span></span><br><span class="line">    atomic.OrUint32(&amp;u32, <span class="number">0x01</span>)</span><br><span class="line">    atomic.AndUint32(&amp;u32, <span class="number">0x00</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指针操作</span></span><br><span class="line">    atomic.PointerInt32(&amp;ptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="163-mutex-是悲观锁还是乐观锁悲观锁-乐观锁是什么"><a class="markdownIt-Anchor" href="#163-mutex-是悲观锁还是乐观锁悲观锁-乐观锁是什么"></a> 16.3、Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？</h2>
<h3 id="1631-悲观锁与乐观锁"><a class="markdownIt-Anchor" href="#1631-悲观锁与乐观锁"></a> 16.3.1 悲观锁与乐观锁</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 悲观锁实现（使用Mutex）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pessimisticLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">    <span class="keyword">var</span> data <span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个goroutine都假设会发生冲突</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            m.Lock()           <span class="comment">// 先获取锁</span></span><br><span class="line">            <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">            data++             <span class="comment">// 安全访问共享数据</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;goroutine %d 完成，数据: %d\n&quot;</span>, id, data)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乐观锁实现（使用atomic操作）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">optimisticLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="type">int64</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个goroutine假设不会发生冲突</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                old := atomic.LoadInt64(&amp;data)</span><br><span class="line">                newVal := old + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 尝试更新，如果失败说明有冲突，重试</span></span><br><span class="line">                <span class="keyword">if</span> atomic.CompareAndSwapInt64(&amp;data, old, newVal) &#123;</span><br><span class="line">                    fmt.Printf(<span class="string">&quot;goroutine %d 完成，数据: %d\n&quot;</span>, id, newVal)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1632-场景选择"><a class="markdownIt-Anchor" href="#1632-场景选择"></a> 16.3.2 场景选择</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据场景选择合适的锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 场景1: 操作频繁，冲突概率高（如热点数据）</span></span><br><span class="line">    <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景2: 操作简单，冲突概率低（如计数器）</span></span><br><span class="line">    <span class="keyword">var</span> counter <span class="type">int64</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景3: 读多写少（如配置读取）</span></span><br><span class="line">    <span class="keyword">var</span> rw sync.RWMutex</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景4: 需要条件判断的同步</span></span><br><span class="line">    <span class="keyword">var</span> cond = sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="164-mutex-有几种模式"><a class="markdownIt-Anchor" href="#164-mutex-有几种模式"></a> 16.4、Mutex 有几种模式？</h2>
<h3 id="1641-mutex的状态"><a class="markdownIt-Anchor" href="#1641-mutex的状态"></a> 16.4.1 Mutex的状态</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutex的核心结构</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="type">int32</span> <span class="comment">// 状态位</span></span><br><span class="line">    sema  <span class="type">uint32</span> <span class="comment">// 信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mutex的状态位定义</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLocked      = <span class="number">1</span> &lt;&lt; <span class="number">0</span>  <span class="comment">// 锁定状态</span></span><br><span class="line">    mutexWoken       = <span class="number">1</span> &lt;&lt; <span class="number">1</span>  <span class="comment">// 唤醒状态</span></span><br><span class="line">    mutexStarving    = <span class="number">1</span> &lt;&lt; <span class="number">2</span>  <span class="comment">// 饥饿状态</span></span><br><span class="line">    mutexWaiterShift = <span class="number">3</span>       <span class="comment">// 等待者数量偏移</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mutex的工作流程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// 1. 快速路径：直接获取锁</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 慢速路径：复杂逻辑处理</span></span><br><span class="line">    m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1642-正常模式与饥饿模式"><a class="markdownIt-Anchor" href="#1642-正常模式与饥饿模式"></a> 16.4.2 正常模式与饥饿模式</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常模式（默认模式）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">normalMode</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 特点：</span></span><br><span class="line">    <span class="comment">// - 等待时间短的goroutine更可能获得锁</span></span><br><span class="line">    <span class="comment">// - 使用先入先出队列管理等待者</span></span><br><span class="line">    <span class="comment">// - 等待者会自旋尝试获取锁（避免上下文切换）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饥饿模式（当有goroutine等待时间超过1ms时触发）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">starvingMode</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 特点：</span></span><br><span class="line">    <span class="comment">// - 锁直接传递给等待时间最长的goroutine</span></span><br><span class="line">    <span class="comment">// - 新到达的goroutine会进入队列的尾部</span></span><br><span class="line">    <span class="comment">// - 当没有等待者或最后一个等待者已被服务时，切换回正常模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制饥饿模式（用于测试）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forceStarvingMode</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动多个长时间等待的goroutine</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            m.Lock()</span><br><span class="line">            time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 长时间持有锁</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;goroutine %d 释放锁\n&quot;</span>, id)</span><br><span class="line">            m.Unlock()</span><br><span class="line">        &#125;(i)</span><br><span class="line">        </span><br><span class="line">        time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="165-goroutine-的自旋占用资源如何解决"><a class="markdownIt-Anchor" href="#165-goroutine-的自旋占用资源如何解决"></a> 16.5、goroutine 的自旋占用资源如何解决</h2>
<h3 id="1651-自旋条件"><a class="markdownIt-Anchor" href="#1651-自旋条件"></a> 16.5.1 自旋条件</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自旋条件（来自Go源代码）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canSpin</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 只能在多核CPU上自旋</span></span><br><span class="line">    <span class="keyword">if</span> gomaxprocs &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有空闲的P，就直接调度</span></span><br><span class="line">    <span class="keyword">if</span> ncpu == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自旋次数限制</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= active_spin &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果P的队列没有可运行的goroutine，说明我们可以尝试自旋</span></span><br><span class="line">    <span class="keyword">if</span> pp := getg().m.p.ptr(); !runqempty(pp) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1652-自旋优化策略"><a class="markdownIt-Anchor" href="#1652-自旋优化策略"></a> 16.5.2 自旋优化策略</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免过多自旋的优化策略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spinOptimization</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 减少临界区代码</span></span><br><span class="line">    <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">    <span class="keyword">var</span> data <span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        m.Lock()</span><br><span class="line">        <span class="comment">// 只包含必要的操作</span></span><br><span class="line">        data++</span><br><span class="line">        m.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 使用读写锁减少锁竞争</span></span><br><span class="line">    <span class="keyword">var</span> rw sync.RWMutex</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        rw.RLock()</span><br><span class="line">        <span class="comment">// 只读操作</span></span><br><span class="line">        fmt.Println(data)</span><br><span class="line">        rw.RUnlock()</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        rw.Lock()</span><br><span class="line">        <span class="comment">// 只包含必要的操作</span></span><br><span class="line">        data++</span><br><span class="line">        rw.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="166-读写锁底层是怎么实现的"><a class="markdownIt-Anchor" href="#166-读写锁底层是怎么实现的"></a> 16.6、读写锁底层是怎么实现的？</h2>
<h3 id="1661-底层实现原理"><a class="markdownIt-Anchor" href="#1661-底层实现原理"></a> 16.6.1 底层实现原理</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RWMutex核心结构</span></span><br><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex        <span class="comment">// 互斥锁，用于写操作</span></span><br><span class="line">    readerCount <span class="type">int32</span>       <span class="comment">// 正在读的goroutine数量</span></span><br><span class="line">    readerWait  <span class="type">int32</span>       <span class="comment">// 等待写完成的goroutine数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读操作获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 有写操作正在进行，阻塞</span></span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.w.sema, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读操作释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 有写操作正在等待，需要唤醒</span></span><br><span class="line">        rw.rUnlockSlow()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写操作获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// 1. 首先获取互斥锁</span></span><br><span class="line">    rw.w.Lock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 计算等待读操作完成的数量</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 等待所有读操作完成</span></span><br><span class="line">    <span class="keyword">if</span> r != <span class="number">0</span> &#123;</span><br><span class="line">        atomic.StoreInt32(&amp;rw.readerWait, r)</span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.w.sema, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写操作释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="comment">// 1. 重置readerCount为正数</span></span><br><span class="line">    atomic.StoreInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 唤醒所有正在等待的读操作</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">int32</span>(<span class="number">0</span>); i &lt; rw.readerCount; i++ &#123;</span><br><span class="line">        runtime_Semrelease(&amp;rw.w.sema, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 释放互斥锁</span></span><br><span class="line">    rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1662-状态转换"><a class="markdownIt-Anchor" href="#1662-状态转换"></a> 16.6.2 状态转换</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RWMutex状态转换示意图</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rwMutexStates</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        StateFree       = <span class="number">0x00</span> <span class="comment">// 无锁状态</span></span><br><span class="line">        StateReading    = <span class="number">0x01</span> <span class="comment">// 读状态（有读操作）</span></span><br><span class="line">        StateWriting    = <span class="number">0x02</span> <span class="comment">// 写状态（有写操作）</span></span><br><span class="line">        StateWaiting    = <span class="number">0x03</span> <span class="comment">// 写等待状态（有写在等待，读继续）</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始状态</span></span><br><span class="line">    state := StateFree</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读操作</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        state = StateReading</span><br><span class="line">        <span class="comment">// 读操作</span></span><br><span class="line">        state = StateFree</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写操作</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        state = StateWaiting</span><br><span class="line">        <span class="comment">// 等待所有读完成</span></span><br><span class="line">        state = StateWriting</span><br><span class="line">        <span class="comment">// 写操作</span></span><br><span class="line">        state = StateFree</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="17-同步原语相关"><a class="markdownIt-Anchor" href="#17-同步原语相关"></a> 17. 同步原语相关</h1>
<h2 id="171-知道哪些-sync-同步原语各有什么作用"><a class="markdownIt-Anchor" href="#171-知道哪些-sync-同步原语各有什么作用"></a> 17.1、知道哪些 sync 同步原语？各有什么作用？</h2>
<h3 id="1711-syncpool高频问题"><a class="markdownIt-Anchor" href="#1711-syncpool高频问题"></a> 17.1.1 sync.Pool（高频问题）</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync.Pool的基本使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolBasic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := sync.Pool&#123;</span><br><span class="line">        New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;创建新对象&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从池中获取对象</span></span><br><span class="line">    obj := p.Get().(*<span class="type">int</span>)</span><br><span class="line">    *obj = <span class="number">42</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 放回到池中</span></span><br><span class="line">    p.Put(obj)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再次从池中获取（很可能是刚才的对象）</span></span><br><span class="line">    obj2 := p.Get().(*<span class="type">int</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;获取到的对象值:&quot;</span>, *obj2) <span class="comment">// 0，因为Get()会重置为零值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用sync.Pool提高性能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolPerformance</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pool sync.Pool</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用pool创建对象</span></span><br><span class="line">    create := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    pool.New = create</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    <span class="keyword">var</span> totalAlloc <span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模拟高并发场景</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从池获取</span></span><br><span class="line">            buf := pool.Get().([]<span class="type">byte</span>)</span><br><span class="line">            <span class="keyword">defer</span> pool.Put(buf)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用buf</span></span><br><span class="line">            _, err := io.ReadFull(rand.Reader, buf)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新分配计数器</span></span><br><span class="line">            mu.Lock()</span><br><span class="line">            totalAlloc += <span class="built_in">len</span>(buf)</span><br><span class="line">            mu.Unlock()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;总分配: %d bytes\n&quot;</span>, totalAlloc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1712-synccond"><a class="markdownIt-Anchor" href="#1712-synccond"></a> 17.1.2 sync.Cond</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync.Cond的基本使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">condBasic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">    queue := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生产者</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            c.L.Lock()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">len</span>(queue) == <span class="number">10</span> &#123;</span><br><span class="line">                c.Wait() <span class="comment">// 队列满了，等待消费者通知</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            queue = <span class="built_in">append</span>(queue, i)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;生产: %d\n&quot;</span>, i)</span><br><span class="line">            </span><br><span class="line">            c.Signal() <span class="comment">// 通知一个消费者</span></span><br><span class="line">            c.L.Unlock()</span><br><span class="line">            </span><br><span class="line">            time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消费者</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            c.L.Lock()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">len</span>(queue) == <span class="number">0</span> &#123;</span><br><span class="line">                c.Wait() <span class="comment">// 队列空了，等待生产者通知</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            item := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            fmt.Printf(<span class="string">&quot;消费: %d\n&quot;</span>, item)</span><br><span class="line">            </span><br><span class="line">            c.Signal() <span class="comment">// 通知一个生产者</span></span><br><span class="line">            c.L.Unlock()</span><br><span class="line">            </span><br><span class="line">            time.Sleep(<span class="number">150</span> * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="172-syncwaitgroup"><a class="markdownIt-Anchor" href="#172-syncwaitgroup"></a> 17.2、sync.WaitGroup</h2>
<h3 id="1721-基本使用"><a class="markdownIt-Anchor" href="#1721-基本使用"></a> 17.2.1 基本使用</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync.WaitGroup的基本使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wgBasic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    tasks := []<span class="type">string</span>&#123;<span class="string">&quot;task1&quot;</span>, <span class="string">&quot;task2&quot;</span>, <span class="string">&quot;task3&quot;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置等待任务数</span></span><br><span class="line">    wg.Add(<span class="built_in">len</span>(tasks))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, task := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            </span><br><span class="line">            fmt.Printf(<span class="string">&quot;开始执行: %s\n&quot;</span>, name)</span><br><span class="line">            time.Sleep(time.Second) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;完成: %s\n&quot;</span>, name)</span><br><span class="line">        &#125;(task)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;等待所有任务完成...&quot;</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;所有任务完成！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WaitGroup与匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wgAnonymous</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 直接使用闭包捕获变量会导致问题</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="comment">// 错误：i和v会是循环的最后一个值</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;索引: %d, 值: %d\n&quot;</span>, i, v)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的做法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wgCorrect</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 使用参数传递避免闭包捕获变量的问题</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx, val <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Printf(<span class="string">&quot;索引: %d, 值: %d\n&quot;</span>, idx, val)</span><br><span class="line">        &#125;(i, v)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1722-waitgroup的高级用法"><a class="markdownIt-Anchor" href="#1722-waitgroup的高级用法"></a> 17.2.2 WaitGroup的高级用法</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用WaitGroup分组处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wgGrouping</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一组任务</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Printf(<span class="string">&quot;第一组任务 %d 完成\n&quot;</span>, id)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待第一组完成</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;第一组任务全部完成！&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二组任务</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt; <span class="number">6</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Printf(<span class="string">&quot;第二组任务 %d 完成\n&quot;</span>, id)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待第二组完成</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;所有任务完成！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h1>
<p>本章节补充了 Channel、Map 和 GMP 相关的重要内容，涵盖了：</p>
<h2 id="channel-相关"><a class="markdownIt-Anchor" href="#channel-相关"></a> Channel 相关</h2>
<ul>
<li>线程安全机制</li>
<li>底层数据结构</li>
<li>nil/关闭/有数据的 channel 操作</li>
<li>发送/接收流程</li>
</ul>
<h2 id="map-相关"><a class="markdownIt-Anchor" href="#map-相关"></a> Map 相关</h2>
<ul>
<li>线程安全解决方案（Mutex、RWMutex、sync.Map、分片锁）</li>
<li>循环顺序问题</li>
<li>内存释放机制</li>
<li>nil map 和空 map 的区别</li>
<li>底层数据结构和扩容机制</li>
<li>取值修改对原 map 的影响</li>
</ul>
<h2 id="gmp-相关"><a class="markdownIt-Anchor" href="#gmp-相关"></a> GMP 相关</h2>
<ul>
<li>调度器组成（G、M、P）</li>
<li>调度流程</li>
<li>任务偷取机制</li>
<li>goroutine 栈特性</li>
<li>goroutine 与操作系统线程的区别</li>
<li>GOMAXPROCS 的影响</li>
<li>调度器的发展历史（协作式到用户态抢占）</li>
</ul>
<p>这些补充内容全面覆盖了 Go 语言面试中的重要考点，包括理论知识、底层实现和实际应用建议，帮助面试者更好地理解和掌握 Go 语言的并发编程模型。</p>

                
                <p class="end">__END__</p>
            </div>
            <div class="article-footer">
                <div class="suffix-box">
    <div class="suffix-box-left">
        <img src="/image/sidebar/avatar.jpg" alt="DYL521">
    </div>
    <div class="suffix-box-right">
        <span class="suffix-box-title">文章作者：</span>DYL521
        <br>
        <span class="suffix-box-title">文章出处：</span><a href="" target="_blank">Golang常见面试题</a>
        <br>
        <span class="suffix-box-title">作者签名：</span>简单地活着, 肆意又精彩.
        <br>
        <span class="suffix-box-title">关于主题：</span><a href="https://github.com/first19326/Hexo-LiveForCode" target="_blank">Hexo - Live For Code</a>
        <br>
        <span class="suffix-box-title">版权声明：</span>文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" title="BY-NC-SA" target="_blank">BY-NC-SA</a> 许可协议，转载请注明出处
        <br>
    </div>
    <div style="clear: both;"></div>
</div>
                
                    <div class="category">
                        分类：
                        
                            <a href="../../../../../categories/go/">go</a>
                        
                            <a href="../../../../../categories/go/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
                        
                    </div>
                
                
                    <div class="tag">
                        标签：
                        
                            <a href="../../../../../tag/go/">go</a>
                        
                            <a href="../../../../../tag/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
                        
                    </div>
                
                <div class="article-prev-next">
                    
                    
                        <a href="../../01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/03.go/03.%E8%BF%90%E8%A1%8C%E6%97%B6/01.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01.%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="next-prefix">» </a> 下一篇：    <a href="../../01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/03.go/03.%E8%BF%90%E8%A1%8C%E6%97%B6/01.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01.%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="发布于 2026-02-22 02:58">01. 内存模型</a>
                    
                </div>
            </div>
            
    <div class="article-comments">
        
            <div class="comments-title">
                评论列表
            </div>
        
        <div class="comments-content"></div>
    </div>
    
 
        </div>
    
</div>
    <div id="footer">
    <div><span class='face'>ღゝ◡╹)ノ♡</span></div><div>【人生若只如初见<span><i class='iconfont icon-like-fill'></i></span>何事秋风悲画扇】</div><div>&copy; 2020-2023 WorstOne. All Rights Reserved.</div>
</div>
    <div id="sidebar">
    <div class="menu-wrap" style="display:none;">
        
            <div class="menu-notice">
                <span class="iconfont icon-notice"></span>
                <div class="notice">
                    <span>简单地活着，肆意而又精彩！</span>
                </div>
            </div>
        
        <nav class="menu">
            <div class="menu-introduce"> 
                <div class="introduce-avatar">
                    <img src="/image/sidebar/avatar.jpg">
                </div> 
                <div class="introduce-info"> 
                    <div class="introduce-user">
                        
                            <a href="https://github.com/DYL521" target="_blank"><span>DYL521</span></a>
                        
                    </div>
                </div> 
            </div> 
            <div class="menu-list">
                <ul>
                    
                        <li class=""><a href="/" class="" target="_self"><span class="iconfont icon-home-fill"></span>首页</a></li>
                    
                        <li class=""><a href="/categories" class="" target="_self"><span class="iconfont icon-folder-fill"></span>分类</a></li>
                    
                        <li class=""><a href="/tag" class="" target="_self"><span class="iconfont icon-discount-fill"></span>标签</a></li>
                    
                        <li class=""><a href="/archives" class="" target="_self"><span class="iconfont icon-calendar-fill"></span>归档</a></li>
                    
                        <li class=""><a href="/donate" class="" target="_self"><span class="iconfont icon-heart-fill"></span>赞赏</a></li>
                    
                        <li class=""><a href="/about" class="" target="_self"><span class="iconfont icon-about-fill"></span>关于</a></li>
                    
                        <li class=""><a href="/atom.xml" class="" target="_blank"><span class="iconfont icon-rss"></span>订阅</a></li>
                    
                        <li class=""><a href="javascript:;" class="search" target="_self"><span class="iconfont icon-search-menu"></span>搜索</a></li>
                    
                        <li class=""><a href="/comment" class="" target="_self"><span class="iconfont icon-comments-fill"></span>留言板</a></li>
                    
                </ul> 
            </div> 
            <div class="menu-link">
                <div class="box">
                    <div class="image-box"></div>
                </div>
                
                    <a name="QQ" href="javascript:;" class="image" target="_self" data="/image/sidebar/qq.png"><span class="iconfont icon-qq"></span></a>
                
                    <a name="微信" href="javascript:;" class="image" target="_self" data="/image/sidebar/wechat.png"><span class="iconfont icon-wechat"></span></a>
                
                    <a name="GitHub" href="https://github.com/DYL521" class="" target="_blank" data=""><span class="iconfont icon-github"></span></a>
                
            </div> 
        </nav>
        <button class="menu-button-close"></button>
        <div class="morph-shape" id="morph-shape" data-morph-open="M-7.312,0H15c0,0,66,113.339,66,399.5C81,664.006,15,800,15,800H-7.312V0z;M-7.312,0H100c0,0,0,113.839,0,400c0,264.506,0,400,0,400H-7.312V0z">
            <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 100 800" preserveAspectRatio="none">
                <path d="M-7.312,0H0c0,0,0,113.839,0,400c0,264.506,0,400,0,400h-7.312V0z"/>
            </svg>
        </div>
    </div>
    <button class="menu-button-open">MENU</button>
    <div class="menu-cover"></div>
</div>
    <link type="text/css" rel="stylesheet" href="/css/search.css">
<script type="text/javascript" src="/js/iscroll.js"></script>
<script type="text/javascript" src="/js/instantsearch.min.js"></script>
<div class="search-window">
    <div class="search-content">
        <div class="search-content-icon">
            <i class="iconfont icon-search"></i>
        </div>
        <div id="search-input" class="search-input"></div>
    </div>

    <div class="search-scroll">
        <div class="search-result">
            <div id="search-stats" class="search-stats"></div>
            <div id="search-hits"></div>
            <div id="search-pagination" class="search-pagination"></div>
        </div>
    </div>

    <span class="search-close-icon">
        <i class="iconfont icon-close"></i>
    </span>
</div>
    <div id="tools">
    <div class="progressbar-top"></div>
    
    <link type="text/css" rel="stylesheet" href="/css/APlayer.css">
    <script type="text/javascript" src="/js/APlayer.min.js"></script>
    <script type="text/javascript" src="/js/Meting.min.js"></script>
    <script>
        var meting_api = 'https://api.i-meto.com/meting/api?server=:server&type=:type&id=:id&auth=:auth&r=:r';
    </script>
    <meting-js id="3778678" lrcshow="false" server="netease" type="playlist" fixed="true" autoplay="false" loop="all" order="random" preload="auto" volume="0.67" mutex="true"></meting-js>

    <div class="wrap-right">
    <div class="wrap-right-hide">
         <div class="wrap-right-button favorites">
            <div class="iconbox" switch="false">
                <span class="iconfont icon-favorites"></span>
            </div>
            <span class="icontext">关注</span>
         </div>
        <div class="wrap-right-button search">
            <div class="iconbox">
                <span class="iconfont icon-search-menu"></span>
            </div>
            <span class="icontext">搜索</span>
        </div>
        <div class="wrap-right-button menu-button">
            <div class="iconbox">
                <span class="iconfont icon-menu"></span>
            </div>
            <span class="icontext">菜单</span>
        </div>
        <div class="wrap-right-button mode">
            <div class="light">
                <div class="iconbox">
                    <span class="iconfont icon-daymode"></span>
                </div>
                <span class="icontext">浅色模式</span>
            </div>
            <div class="dark">
                <div class="iconbox">
                    <span class="iconfont icon-nightmode-fill"></span>
                </div>
                <span class="icontext">深色模式</span>
            </div>
        </div>
        <div class="wrap-right-button bottom">
            <div class="iconbox">
                <span class="iconfont icon-top"></span>
            </div>
            <span class="icontext">跳至底部</span>
        </div>
    </div>
    <div class="wrap-right-show">
        <div class="wrap-right-button set">
            <div class="iconbox">
                <span class="iconfont icon-setting"></span>
            </div>
            <span class="icontext">设置</span>
        </div>
        <div class="wrap-right-button top">
            <div class="iconbox">
                <span class="iconfont icon-top"></span>
            </div>
            <span class="icontext">返回顶部</span>
        </div>
    </div>
</div>
    <div class="loading"></div>
</div>
    <script>
    window.config = {
        GitHubUserName     : "first19326",
        GitHubRepositories : "Hexo-LiveForCode",

        User             : "DYL521",
        UserAvatar       : "/image/sidebar/avatar.jpg",
        WebsiteStartDate : "2020-01-01",
        Home             : "https://github.com/DYL521",

        WebsiteTitleBlur         : "(◍´꒳`◍) Hi, DYL521",
        WebsiteTitleBlurTimeOut  : 500,
        WebsiteTitleFocus        : "(*´∇｀*) 欢迎回来!",
        WebsiteTitleFocusTimeOut : 1000,
        WebsiteFavicon           : {
            light : "/image/website/logo/logo.png",
            dark  : "/image/website/logo/logo-dark.png"
        },

        ProgressBar : {
            id       : "topProgressBar",
            color    : "#77B6FF",
            height   : "2px",
            duration : 0.2
        },

        Loading: {
            rebound : {
                tension  : 16,
                friction : 5
            },
            spinner : {
                id     : "spinner",
                radius : 90,
                sides  : 3,
                depth  : 4,
                colors : {
                    background : "#F0F0F0",
                    stroke     : "#272633",
                    base       : "",
                    child      : "#272633"
                },
                alwaysForward : true,
                restAt        : 0.5,
                renderBase    : false
            }
        },

        HomeHeaderAnimationRendered : true,
        HomeHeaderAnimation         : {
            radius      : 15,
            density     : 0.2,
            color       : "rgba(255, 255, 255, .2)",
            clearOffset : 0.3
        },

        BackAnimationRendered          : true,
        IEBrowserBackAnimationRendered : false,
        BackAnimation                  : {
            colorSaturation  : "60%",
            colorBrightness  : "50%",
            colorAlpha       : 0.5,
            colorCycleSpeed  : 5,
            verticalPosition : "random",
            horizontalSpeed  : 200,
            ribbonCount      : 3,
            strokeSize       : 0,
            parallaxAmount   : -0.2,
            animateSections  : true
        },

        HomeHeaderImage : [
            
                "/image/header/home.jpg",
            
                "/image/header/home2.jpg",
            
        ],
        HomeBannerText  : "",

        ArticleHeaderImage : [
            
                "/image/header/article2.jpeg",
            
                "/image/header/article3.jpg",
            
        ],

        OtherBannerText : "",

        Error : {
            icon    : "icon-swimming",
            title   : "PAGE NOT FOUND",
            content : [
                
                    "很抱歉，您访问的页面不存在！",
                
                    "可能是输入地址有误或该地址已变更。",
                
            ],
            buttons : [
                
                    {
                        icon  : "icon-home",
                        text  : "返回首页",
                        href  : "/",
                        class : ""
                    },
                
            ]
        },

        MenuNotice : {
            enable : true,
            notice : "简单地活着，肆意而又精彩！",
            speed  : 20
        },
        MenuList : [
            
                {
                    name   : "首页",
                    icon   : "icon-home-fill",
                    href   : "/",
                    type   : "index",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "分类",
                    icon   : "icon-folder-fill",
                    href   : "/categories",
                    type   : "category",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "标签",
                    icon   : "icon-discount-fill",
                    href   : "/tag",
                    type   : "tag",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "归档",
                    icon   : "icon-calendar-fill",
                    href   : "/archives",
                    type   : "archives",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "赞赏",
                    icon   : "icon-heart-fill",
                    href   : "/donate",
                    type   : "donate",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "关于",
                    icon   : "icon-about-fill",
                    href   : "/about",
                    type   : "about",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "订阅",
                    icon   : "icon-rss",
                    href   : "/atom.xml",
                    type   : "",
                    class  : "",
                    target : "_blank"
                },
            
                {
                    name   : "搜索",
                    icon   : "icon-search-menu",
                    href   : "javascript:;",
                    type   : "",
                    class  : "search",
                    target : "_self"
                },
            
                {
                    name   : "留言板",
                    icon   : "icon-comments-fill",
                    href   : "/comment",
                    type   : "comment",
                    class  : "",
                    target : "_self"
                },
            
        ],
        MenuLink : [
            
                
                    {
                        name   : "QQ",
                        icon   : "icon-qq",
                        href   : "javascript:;",
                        class  : "image",
                        target : "_self",
                        image  : "/image/sidebar/qq.png"
                    },
                
                    {
                        name   : "微信",
                        icon   : "icon-wechat",
                        href   : "javascript:;",
                        class  : "image",
                        target : "_self",
                        image  : "/image/sidebar/wechat.png"
                    },
                
                    {
                        name   : "GitHub",
                        icon   : "icon-github",
                        href   : "https://github.com/DYL521",
                        class  : "",
                        target : "_blank",
                        image  : ""
                    },
                
            
        ],

        FooterStyle : 2,
        BottomText  : "<div><span class='face'>ღゝ◡╹)ノ♡</span></div><div>【人生若只如初见<span><i class='iconfont icon-like-fill'></i></span>何事秋风悲画扇】</div><div>&copy; 2020-2023 WorstOne. All Rights Reserved.</div>",

        ConsoleList : [
            
                
                    [
                        
                            
                                "Based on cnblogs theme SimpleMemory.",
                            
                                "",
                            
                        
                    ],
                
                    [
                        
                            
                                "SimpleMemory Author:",
                            
                                "BNDong",
                            
                        
                    ],
                
                    [
                        
                            
                                "Theme:",
                            
                                "LiveForCode",
                            
                        
                    ],
                
            
        ],

        FontIconExtend : "",

        Donate : {
            paypal  : "",
            bitcoin : "",
            alipay  : "/image/donate/alipay.png",
            wechat  : "/image/donate/wechat.png"
        },

        Search : {
            applicationID : "LL15RDN4FO",
            apiKey        : "c5a7149ea9f6f1ac6b20c7e1513ff90d",
            indexName     : "hexo-blog",
            hits          : {
                page : 10
            },
            labels        : {
                placeholder : "搜索",
                empty       : "未发现与 「${query}」 相关的内容",
                stats       : "${hits} 条相关条目，使用了 ${time} 毫秒",
            }
        }, 

        Comment : {
            switch : true,
            type   : "Valine",
        },

        Waline : {
            el              : ".comments-content",
            serverURL       : "",
            path            : window.location.pathname,
            meta            : "['nick', 'mail', 'link']",
            requiredMeta    : "['nick', 'mail']",
            pageSize        : 10,
            lang            : "zh-cn",
            locale: {
                admin       : "博主",
                anonymous   : "匿名用户",
                sofa        : "快来做第一个评论的人吧 ~",
                placeholder : "你是我一生只会遇见一次的惊喜...",
            },
            dark            : "html[color-scheme='dark']",
            search          : false,
            pageview        : true,
            comment         : true,
            copyright       : false,
        },

        Valine : {
            el             : ".comments-content",
            appId          : "srhKtvWPQTWYKh3qX8G8M7v0-gzGzoHsz",
            appKey         : "8uVSP1q6UlALVC5igYfIfv2h",
            serverURLs     : "",
            placeholder    : "你是我一生只会遇见一次的惊喜...",
            avatar         : "mm",
            meta           : "nick,mail,link",
            requiredFields : "nick,mail",
            pageSize       : 5,
            lang           : "zh-cn",
            visitor        : true,
            enableQQ       : true
        },

        Tocbot : {
            switch                : true,
            tocSelector           : ".toc",
            contentSelector       : ".article-body",
            headingSelector       : "h1, h2, h3, h4, h5",
            headingsOffset        : 0,
            scrollSmooth          : true,
            scrollSmoothOffset    : -5,
            positionFixedSelector : ".toc",
            positionFixedClass    : "toc-fixed",
            fixedSidebarOffset    : "",
        },

        Require : {
            baseUrl     : "/js/",
            waitSeconds : 100
        },

        Music : {
            type : "Meting"
        },
        APlayer : {
            container : ".aplayer",
            fixed     : true,
            autoplay  : false,
            loop      : "all",
            order     : "random",
            preload   : "auto",
            volume    : 0.67,
            mutex     : true,
            lrcType   : 3,
            audio     : [
                
                    {
                        name   : "Endless Tears",
                        artist : "CLIFF EDGE",
                        cover  : "/music/cover/Endless Tears.jpg",
                        url    : "/music/song/Endless Tears.mp3",
                        lrc    : "/music/lrc/Endless Tears.lrc"
                    },
                
            ]
        },
        Meting : {
            api      : "https://api.i-meto.com/meting/api",
            id       : "3778678", 
            lrcshow  : false, 
            server   : "netease", 
            type     : "playlist", 
            fixed    : true, 
            autoplay : false, 
            loop     : "all", 
            order    : "random", 
            preload  : "auto", 
            volume   : 0.67, 
            mutex    : true
        },

        Mouse : {
            enable  : true,
            options : {
                size  : 6,
                sizeF : 24
            }
        },

        LazyLoad : {
            default : "/image/website/lazyload.svg"
        },
  
        Style : {
            aplayer          : "/css/APlayer.css",
            archive          : "/css/archive.css",
            base             : "/css/base.css",
            clipboard        : "/css/clipboard.css",
            code             : "/css/code.css",
            donate           : "/css/donate.css",
            fancybox         : "/css/jquery.fancybox.css",
            footer           : "/css/footer.css",
            iconfont         : "/iconfont/iconfont.css",
            index            : "/css/index.css",
            menuBubble       : "/css/menu-bubble.css",
            mouse            : "/css/mouse.css",
            page             : "/css/page.css",
            post             : "/css/post.css",
            search           : "/css/search.css",
            tocbot           : "/css/tocbot.css",
            valine           : "/css/valine.css",
            waline           : "/css/waline.css",
            walineCustom     : "/css/waline-custom.css"
        },

        Script: {
            aplayer          : "/js/APlayer.min.js",
            config           : "/js/require.config.js",
            index            : "/js/index.js",
            instantSearch    : "/js/instantsearch.min.js",
            iscroll          : "/js/iscroll.js",
            jQuery           : "/js/jquery-3.4.1.min.js",
            loading          : "/js/loading.js",
            meting           : "/js/Meting.min.js",
            require          : "/js/require.min.js",
            waline           : "/js/waline.mjs",
            pageview         : "/js/pageview.mjs",
            comment          : "/js/comment.mjs",
        },

        Font: {
            LongCang    : "/font/LongCang.css",
            Monda       : "/font/Monda.css",
            NotoSansSC  : "/font/NotoSansSC.css",
            NotoSerifSC : "/font/NotoSerifSC.css",
            Playball    : "/font/Playball.css",
            PTMono      : "/font/PTMono.css",
            Roboto      : "/font/Roboto.css",
            RobotoSlab  : "/font/RobotoSlab.css",
            Rosario     : "/font/Rosario.css",
            UbuntuMono  : "/font/UbuntuMono.css"
        },

        Suffix : {
            about : "简单地活着, 肆意又精彩."
        },
            
        Theme : {
            url  : "https://github.com/first19326/Hexo-LiveForCode",
            name : "Hexo - Live For Code"
        }  
    };
</script>
    <script type="text/javascript" src="/js/prism.js"></script>
    <script type="text/javascript" src="/js/code-highlight.js"></script>
    <script type="text/javascript" src="/js/index.js"></script>
</body>
</html>